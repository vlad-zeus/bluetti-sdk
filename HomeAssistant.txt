--- START OF FILE HomeAssistant.txt ---

BUILD_META={"bundle": "HomeAssistant.txt", "created_at": "2026-02-14 14:26:50", "git_commit": "10a3c1631adf4ef6837b159ec9de23fdeaf5668f", "params": {"dedupe": true, "dry_run": false, "exclude_dir_glob": [], "exclude_dir_if_over": 0, "exclude_glob": [], "include_glob": [], "json_summary": "", "keep": 3, "keep_by": "mtime", "mask_aggressive": false, "mask_secrets": true, "max_file_size": 2097152, "max_total_size": 52428800, "respect_gitignore": true, "strip_ipynb": true}, "project_root": "D:\\HomeAssistant"}

=== НАЧАЛО ФАЙЛА: .claude/settings.local.json ===
{
  "permissions": {
    "allow": [
      "Bash(ssh:*)",
      "Bash(python:*)",
      "Bash(ping:*)",
      "Bash(dir:*)",
      "Bash(ls:*)",
      "Bash(unzip:*)",
      "Bash(for f in classes*.dex)",
      "Bash(do cat \"$f\")",
      "Bash(done)",
      "Bash(strings:*)",
      "Bash(grep:*)",
      "Bash(dd:*)",
      "Bash(python3 -c \"\nimport requests\nimport json\n\n# Token from HA\naccess_token = ''eyJjdHkiOiJKV1QiLCJlbmMiOiJBMjU2R0NNIiwiYWxnIjoiZGlyIn0.56DA68A53093175A64201006D6877EF6.pxbG4aY_aATVmGK6.6_UZqmuFZieowznM8b9x1PImwM8KiciS8C-KHK9PMl_ADL0dSuJ5wJQUJpmwf6rj4Pw8bK-j-WWubo05k5vLIybXo5LnAoZnAIJl_jiKmDywAWBzDulKP_RBQvXA8c8pGhtNjsSA_C_O07GK1auvNkbULqkEm55fVIr1OxJljjqf4PwnHHvTkw5oZBSshsmPcyMfEQmiF3Y8CPXittoWdzbaSn7yc6vN3T4KN3LXgx9h0cEFE68ueP8MjpYsQbhGHR-2woCrs8zrKSEaqLuGfRh-iCesUY1SmxpHpZEksu87KHJAzBO62Qd335Ti4s2u_3voXLLzpYuJ2MlL5jsleqYaSnRh3HHJhBMYYphfD7xqSMR-QpFsDvdibWaKe0z_wmEMeH50bnAjrdvfwFEEl0Amf-bw77Hd9Dsw9KAc5FvUxoKfjPquSBvRRfpV5x37IN6wostXWHGku7SRkhvATFdXCnmanuB0zRzPwb7CxuPCPnoKuvEOQzr7-IBLJNfNU2CMuDVuGhzQmUTf_tPl0dgLtaMflLnPmty04uADeZBZWsYILLNydtXAkGKK2vVxwG1j1OTC_RZw3b5PnMMXjlopCNENybtjjD_qdZ4QAUkHdAQH-St3_2WG617rsUGMVsa4r41YVMgnhJpa6hCrIlI6sH8F6t2udd0UTx3TBUwOxZ-8Tg6cG3NEzJOMRCs8Oquxeyuls_Dp1d9FTPucbamw8dR30SAuHFsSQhMDilcqP12SSFZKVy9t15ORP_Ki-b5Ql-iSUisSrNwhfUZ1c3g5LWRl0PU5jwLiQXS_F2HQibpdUvnbsGGPEJCTRJSyUxLM4-I7H6Zw8LxAz4Y-x9JxgrvIGuaUVtu8yV3nLO-pza1uIzmXNXSfdBJlSO-4HM0J2uqtNyvOmAsP5X2JXjUL2K4VKsEHTV1Sxk528Qma3lP7yj62v8Hr1weNxXJpSVpotCcNqJ5KbVKnAuWnAFRIH3g7j17Lo0jFmdV5x4XBMBW7QhzpkUzZGOYeXCGgUCr77riy_7IrMyWUQv4gz2s0q_TZ44wx5gIQNkS5vGsM3g6bzwAu0zgOOUb9hdt_tyTgetJqypVjJnwzhnSawxhnYdYcAg6ewG_rI7TdGETB4fD0YtVMawZON_Q9t2Yxem30tXlpMAFfjSxpxavaZw71QRQCSCIh_0eFr5QXO_uNqEqgDNC97MnqvXwKawkFMRiI26RV2JTs13O8qVIkzycTCSFo5qlfe2CB5eEHPSWl0sjWDvwZ4tki7vYOuL6kc-bLrarh1yQYdLDrL93pAiSH5Nlnni6SGcSUzgYXev_vMAFSHRZDd9ykjDB2kkslx17VO8ufhLlUOJSlUH9U_cc5xyIeephGJ14YOXHH4z439D9kjWG0jM1DgDwsz7c7k_kHI7AMKfS-GwQhdUt1yDn_h2P1Yivn-jtCNBJS90Wz9eYFLoaHy412sIMBjw_uSO9P3_or4pRq2U3DtHrS7D7EXl-Xed09A-ComyRk78DquiJcPUw8KJSMEkbPRfQzlBWH.IPqSN3eFBrJdiMp7MGAAQQ''\n\nheaders = {\n    ''Authorization'': access_token,\n    ''Content-Type'': ''application/json'',\n    ''User-Agent'': ''okhttp/4.9.3''\n}\n\n# Test 1: Get device topic list\nprint\\(''=== Testing /api/bluuc/push/v1/device/topic/list ===''\\)\nurl = ''https://gw.bluettipower.com/api/bluuc/push/v1/device/topic/list''\nresp = requests.get\\(url, headers=headers, params={''deviceSn'': ''EL100V22537001950322''}\\)\nprint\\(f''Status: {resp.status_code}''\\)\nprint\\(json.dumps\\(resp.json\\(\\), indent=2, ensure_ascii=False\\)[:1500]\\)\n\nprint\\(\\)\n\n# Test 2: Get PFX certificate\nprint\\(''=== Testing /api/midppkic/cert/app/v1/pfx ===''\\)\nurl = ''https://gw.bluettipower.com/api/midppkic/cert/app/v1/pfx''\nresp = requests.post\\(url, headers=headers, json={}\\)\nprint\\(f''Status: {resp.status_code}''\\)\nprint\\(json.dumps\\(resp.json\\(\\), indent=2, ensure_ascii=False\\)[:1500]\\)\n\")",
      "Bash(curl:*)",
      "Bash(TOKEN=\"eyJjdHkiOiJKV1QiLCJlbmMiOiJBMjU2R0NNIiwiYWxnIjoiZGlyIn0.56DA68A53093175A64201006D6877EF6.pxbG4aY_aATVmGK6.6_UZqmuFZieowznM8b9x1PImwM8KiciS8C-KHK9PMl_ADL0dSuJ5wJQUJpmwf6rj4Pw8bK-j-WWubo05k5vLIybXo5LnAoZnAIJl_jiKmDywAWBzDulKP_RBQvXA8c8pGhtNjsSA_C_O07GK1auvNkbULqkEm55fVIr1OxJljjqf4PwnHHvTkw5oZBSshsmPcyMfEQmiF3Y8CPXittoWdzbaSn7yc6vN3T4KN3LXgx9h0cEFE68ueP8MjpYsQbhGHR-2woCrs8zrKSEaqLuGfRh-iCesUY1SmxpHpZEksu87KHJAzBO62Qd335Ti4s2u_3voXLLzpYuJ2MlL5jsleqYaSnRh3HHJhBMYYphfD7xqSMR-QpFsDvdibWaKe0z_wmEMeH50bnAjrdvfwFEEl0Amf-bw77Hd9Dsw9KAc5FvUxoKfjPquSBvRRfpV5x37IN6wostXWHGku7SRkhvATFdXCnmanuB0zRzPwb7CxuPCPnoKuvEOQzr7-IBLJNfNU2CMuDVuGhzQmUTf_tPl0dgLtaMflLnPmty04uADeZBZWsYILLNydtXAkGKK2vVxwG1j1OTC_RZw3b5PnMMXjlopCNENybtjjD_qdZ4QAUkHdAQH-St3_2WG617rsUGMVsa4r41YVMgnhJpa6hCrIlI6sH8F6t2udd0UTx3TBUwOxZ-8Tg6cG3NEzJOMRCs8Oquxeyuls_Dp1d9FTPucbamw8dR30SAuHFsSQhMDilcqP12SSFZKVy9t15ORP_Ki-b5Ql-iSUisSrNwhfUZ1c3g5LWRl0PU5jwLiQXS_F2HQibpdUvnbsGGPEJCTRJSyUxLM4-I7H6Zw8LxAz4Y-x9JxgrvIGuaUVtu8yV3nLO-pza1uIzmXNXSfdBJlSO-4HM0J2uqtNyvOmAsP5X2JXjUL2K4VKsEHTV1Sxk528Qma3lP7yj62v8Hr1weNxXJpSVpotCcNqJ5KbVKnAuWnAFRIH3g7j17Lo0jFmdV5x4XBMBW7QhzpkUzZGOYeXCGgUCr77riy_7IrMyWUQv4gz2s0q_TZ44wx5gIQNkS5vGsM3g6bzwAu0zgOOUb9hdt_tyTgetJqypVjJnwzhnSawxhnYdYcAg6ewG_rI7TdGETB4fD0YtVMawZON_Q9t2Yxem30tXlpMAFfjSxpxavaZw71QRQCSCIh_0eFr5QXO_uNqEqgDNC97MnqvXwKawkFMRiI26RV2JTs13O8qVIkzycTCSFo5qlfe2CB5eEHPSWl0sjWDvwZ4tki7vYOuL6kc-bLrarh1yQYdLDrL93pAiSH5Nlnni6SGcSUzgYXev_vMAFSHRZDd9ykjDB2kkslx17VO8ufhLlUOJSlUH9U_cc5xyIeephGJ14YOXHH4z439D9kjWG0jM1DgDwsz7c7k_kHI7AMKfS-GwQhdUt1yDn_h2P1Yivn-jtCNBJS90Wz9eYFLoaHy412sIMBjw_uSO9P3_or4pRq2U3DtHrS7D7EXl-Xed09A-ComyRk78DquiJcPUw8KJSMEkbPRfQzlBWH.IPqSN3eFBrJdiMp7MGAAQQ\")",
      "Bash(scp:*)",
      "Bash(pip show:*)",
      "Bash(pip3 show:*)",
      "WebSearch",
      "WebFetch(domain:raw.githubusercontent.com)",
      "WebFetch(domain:api.github.com)",
      "WebFetch(domain:github.com)",
      "WebFetch(domain:diysolarforum.com)",
      "Bash(where:*)",
      "Bash(for f in d:/HomeAssistant/bluetti_apk/classes*.dex)",
      "Bash(do strings:*)",
      "Bash(scoop search:*)",
      "Bash(choco search:*)",
      "Bash(jadx_tool/bin/jadx.bat:*)",
      "WebFetch(domain:community.bluettipower.com)",
      "Bash(winget install:*)",
      "Bash(set \"JAVA_HOME=C:\\\\Program Files\\\\Microsoft\\\\jdk-21.0.10.7-hotspot\")",
      "Bash(set \"PATH=%JAVA_HOME%\\\\bin;%PATH%\")",
      "Bash(cmd /c \"set JAVA_HOME=C:\\\\Program Files\\\\Microsoft\\\\jdk-21.0.10.7-hotspot && set PATH=%JAVA_HOME%\\\\bin;%PATH% && cd /d d:\\\\HomeAssistant && jadx_tool\\\\bin\\\\jadx.bat -d bluetti_decompiled --show-bad-code BLUETTI_3.0.5_APKPure.apk\")",
      "Bash(export JAVA_HOME=\"/c/Program Files/Microsoft/jdk-21.0.10.7-hotspot\")",
      "Bash(export PATH=\"$JAVA_HOME/bin:$PATH\")",
      "Bash(java:*)",
      "Bash(\"/c/Program Files/Microsoft/jdk-21.0.10.7-hotspot/bin/java\" -jar \"d:/HomeAssistant/jadx_tool/lib/jadx-1.5.0-all.jar\" -d \"d:/HomeAssistant/bluetti_decompiled\" --show-bad-code \"d:/HomeAssistant/BLUETTI_3.0.5_APKPure.apk\")",
      "Bash(\"/c/Program Files/Microsoft/jdk-21.0.10.7-hotspot/bin/java\" -jar \"d:/HomeAssistant/apktool.jar\" d:*)",
      "Bash(copy \"d:\\\\HomeAssistant\\\\bluetti_smali\\\\res\\\\raw\\\\ca_prod.crt\" \"d:\\\\HomeAssistant\\\\bluetti_ca.crt\")",
      "Bash(find:*)",
      "Bash(cd:*)",
      "Bash(findstr:*)",
      "Bash(wc:*)",
      "Bash(tree:*)",
      "Bash(pip install:*)",
      "Bash(git add:*)",
      "Bash(git commit:*)",
      "Bash(pytest:*)",
      "Bash(git show:*)"
    ]
  }
}
=== КОНЕЦ ФАЙЛА: .claude/settings.local.json ===

=== НАЧАЛО ФАЙЛА: .github/workflows/quality.yml ===
name: Quality

on:
  push:
    branches: [main]
  pull_request:

jobs:
  quality:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -e ".[dev]"

      - name: Ruff lint
        run: ruff check bluetti_sdk/contracts bluetti_sdk/schemas bluetti_sdk/devices

      - name: Ruff format check
        run: ruff format --check bluetti_sdk/contracts bluetti_sdk/schemas bluetti_sdk/devices

      - name: MyPy
        run: mypy bluetti_sdk/contracts bluetti_sdk/schemas bluetti_sdk/devices

      - name: Tests
        run: pytest -q
=== КОНЕЦ ФАЙЛА: .github/workflows/quality.yml ===

=== НАЧАЛО ФАЙЛА: .pre-commit-config.yaml ===
repos:
  - repo: https://github.com/astral-sh/ruff-pre-commit
    rev: v0.12.9
    hooks:
      - id: ruff-check
        pass_filenames: false
        args:
          - --fix
          - bluetti_sdk/contracts
          - bluetti_sdk/schemas
          - bluetti_sdk/devices
      - id: ruff-format
        pass_filenames: false
        args:
          - bluetti_sdk/contracts
          - bluetti_sdk/schemas
          - bluetti_sdk/devices

  - repo: https://github.com/pre-commit/mirrors-mypy
    rev: v1.17.1
    hooks:
      - id: mypy
        pass_filenames: false
        args:
          - --config-file=pyproject.toml
          - bluetti_sdk/contracts
          - bluetti_sdk/schemas
          - bluetti_sdk/devices
        additional_dependencies:
          - types-setuptools
=== КОНЕЦ ФАЙЛА: .pre-commit-config.yaml ===

=== НАЧАЛО ФАЙЛА: bluetti_sdk/__init__.py ===
"""Bluetti SDK - Official Python SDK for Bluetti Elite V2 Devices

This SDK provides a clean, type-safe interface for interacting with
Bluetti Elite V2 power stations via MQTT.

Quick Start:
    >>> from bluetti_sdk import BluettiClient, MQTTTransport, MQTTConfig, get_device_profile
    >>>
    >>> config = MQTTConfig(
    ...     device_sn="2345EB200xxxxxxx",
    ...     pfx_cert=cert_bytes,
    ...     cert_password="password"
    ... )
    >>>
    >>> transport = MQTTTransport(config)
    >>> profile = get_device_profile("EL100V2")
    >>> client = BluettiClient(transport, profile)
    >>> client.connect()
    >>>
    >>> # Read grid information
    >>> grid_data = client.read_block(1300)
    >>> print(f"Grid voltage: {grid_data.values['phase_0_voltage']} V")

Public API:
    - BluettiClient: Main client for device interaction
    - MQTTTransport: MQTT transport implementation
    - MQTTConfig: MQTT configuration
    - DeviceProfile: Device configuration
    - Errors: BluettiError, TransportError, ProtocolError, ParserError
"""

__version__ = "2.0.0"
__author__ = "Zeus Fabric Team"
__license__ = "MIT"

# Core client
from .client import ReadGroupResult
from .client import V2Client as BluettiClient
from .client_async import AsyncV2Client

# Errors
from .errors import (
    BluettiError,
    DeviceError,
    ParserError,
    ProtocolError,
    TransportError,
)

# Models
from .devices.profiles import get_device_profile
from .devices.types import DeviceProfile
from .models.device import V2Device as BluettiDevice

# Protocol V2 (advanced usage)
from .protocol.v2 import (
    ArrayField,
    BlockSchema,
    Field,
    PackedField,
    SubField,
    V2Parser,
)

# Transport layer
from .transport.mqtt import MQTTConfig, MQTTTransport

__all__ = [
    # Version
    "__version__",
    # Client
    "BluettiClient",
    "AsyncV2Client",
    "ReadGroupResult",
    # Transport
    "MQTTTransport",
    "MQTTConfig",
    # Models
    "BluettiDevice",
    "DeviceProfile",
    "get_device_profile",
    # Errors
    "BluettiError",
    "TransportError",
    "ProtocolError",
    "ParserError",
    "DeviceError",
    # V2 Protocol (advanced)
    "V2Parser",
    "BlockSchema",
    "Field",
    "ArrayField",
    "PackedField",
    "SubField",
]
=== КОНЕЦ ФАЙЛА: bluetti_sdk/__init__.py ===

=== НАЧАЛО ФАЙЛА: bluetti_sdk/client.py ===
"""V2 Client - Layer Orchestration

High-level client that orchestrates all layers:
    transport → protocol → v2_parser → device_model

This is the PUBLIC API for V2 devices.
"""

import logging
from dataclasses import dataclass
from typing import Dict, List, Optional, Tuple

from . import schemas
from .contracts import (
    BluettiClientInterface,
    DeviceModelInterface,
    TransportProtocol,
    V2ParserInterface,
)
from .devices.types import DeviceProfile
from .errors import ParserError, ProtocolError, TransportError
from .models.device import V2Device
from .models.types import BlockGroup
from .protocol.modbus import (
    build_modbus_request,
    normalize_modbus_response,
    parse_modbus_frame,
    validate_crc,
)
from .protocol.v2.parser import V2Parser
from .protocol.v2.types import ParsedBlock
from .schemas.registry import SchemaRegistry

logger = logging.getLogger(__name__)


@dataclass
class ReadGroupResult:
    """Result of read_group operation.

    Attributes:
        blocks: Successfully parsed blocks
        errors: List of (block_id, exception) for failed blocks
    """

    blocks: List["ParsedBlock"]
    errors: List[Tuple[int, Exception]]

    @property
    def success(self) -> bool:
        """Check if all blocks were read successfully."""
        return len(self.errors) == 0

    @property
    def partial(self) -> bool:
        """Check if some (but not all) blocks failed."""
        return len(self.errors) > 0 and len(self.blocks) > 0


class V2Client(BluettiClientInterface):
    """High-level V2 client.

    Orchestrates layers without knowing implementation details:
    - Transport: sends/receives frames
    - Protocol: normalizes Modbus
    - Parser: parses blocks
    - Device: stores state

    Usage:
        client = V2Client(transport, device_profile)
        client.connect()

        # Read single block
        parsed = client.read_block(1300)
        print(f"Grid: {parsed.values['phase_0_voltage']}V")

        # Read block group
        blocks = client.read_group(BlockGroup.GRID)

        # Get device state
        state = client.get_device_state()

    Concurrency:
        A single V2Client instance is intended for serialized access.
        Do not call read/connect/disconnect concurrently from multiple threads.
    """

    def __init__(
        self,
        transport: TransportProtocol,
        profile: DeviceProfile,
        device_address: int = 1,
        parser: Optional[V2ParserInterface] = None,
        device: Optional[DeviceModelInterface] = None,
        schema_registry: Optional[SchemaRegistry] = None,
    ):
        """Initialize V2 client with dependency injection.

        Args:
            transport: Transport layer implementation
            profile: Device profile with configuration
            device_address: Modbus device address (default: 1)
            parser: Parser implementation (creates V2Parser if None)
            device: Device model implementation (creates V2Device if None)
            schema_registry: Schema registry (creates instance with built-ins if None)

        Note:
            Parser and device are injected via constructor for testability.
            If not provided, default implementations are created.
        """
        self.transport = transport
        self.profile = profile
        self.device_address = device_address
        self.schema_registry = (
            schema_registry
            if schema_registry is not None
            else schemas.new_registry_with_builtins()
        )

        # Inject or create V2 parser
        self.parser = parser if parser is not None else V2Parser()

        # Inject or create device model
        self.device = device if device is not None else V2Device(
            device_id=f"{profile.model}_{device_address}",
            model=profile.model,
            protocol_version=2000,  # V2 protocol
        )

        # Auto-register schemas from SchemaRegistry
        self._auto_register_schemas()

    def _auto_register_schemas(self):
        """Auto-register schemas for all blocks in device profile.

        Collects block IDs from device profile, resolves schemas from global
        SchemaRegistry, and registers them in the parser.

        This eliminates temporal coupling - no need for manual schema registration.
        """
        # Collect all block IDs from profile groups
        block_ids = set()
        for group in self.profile.groups.values():
            block_ids.update(group.blocks)

        if not block_ids:
            logger.warning(
                f"Device profile '{self.profile.model}' has no blocks defined"
            )
            return

        logger.debug(
            f"Auto-registering schemas for {len(block_ids)} blocks: {sorted(block_ids)}"
        )

        # Resolve schemas from client-scoped registry (strict=False for flexibility)
        try:
            resolved_schemas = self.schema_registry.resolve_blocks(
                list(block_ids), strict=False
            )
        except ValueError as e:
            logger.error(f"Failed to resolve schemas: {e}")
            resolved_schemas = {}

        # Register resolved schemas in parser
        for block_id, schema in resolved_schemas.items():
            self.parser.register_schema(schema)
            logger.debug(f"Registered schema: Block {block_id} ({schema.name})")

        # Warn about missing schemas
        missing = block_ids - set(resolved_schemas.keys())
        if missing:
            logger.warning(
                f"Schemas not found for blocks: {sorted(missing)}. "
                f"These blocks cannot be parsed. "
                f"Available schemas: {self.schema_registry.list_blocks()}"
            )

    def connect(self):
        """Connect to device."""
        logger.info(f"Connecting to {self.profile.model}...")
        self.transport.connect()

        if not self.transport.is_connected():
            raise TransportError("Failed to connect to device")

        logger.info(f"Connected to {self.profile.model}")

    def disconnect(self):
        """Disconnect from device."""
        logger.info("Disconnecting...")
        self.transport.disconnect()

    def read_block(
        self, block_id: int, register_count: Optional[int] = None
    ) -> ParsedBlock:
        """Read and parse a V2 block.

        This is the core method that orchestrates all layers.

        Flow:
            1. Build Modbus request (protocol layer)
            2. Send via transport
            3. Parse Modbus response (protocol layer)
            4. Normalize to bytes (protocol layer)
            5. Parse block (v2_parser)
            6. Update device model
            7. Return ParsedBlock

        Args:
            block_id: Block ID to read
            register_count: Number of registers (auto-calculated if None)

        Returns:
            ParsedBlock with parsed data

        Raises:
            TransportError: If transport fails
            ProtocolError: If Modbus error
            ParserError: If parsing fails
        """
        # Auto-calculate register count from schema
        if register_count is None:
            schema = self.parser.get_schema(block_id)
            if schema:
                # min_length is in bytes, registers are 2 bytes each
                register_count = (schema.min_length + 1) // 2
            else:
                raise ParserError(
                    f"No schema registered for block {block_id} "
                    f"and register_count not specified"
                )

        logger.debug(
            f"Reading block {block_id} "
            f"({register_count} registers = {register_count * 2} bytes)"
        )

        # === Layer 1: Protocol - Build Modbus request ===
        request = build_modbus_request(
            device_address=self.device_address,
            block_address=block_id,
            register_count=register_count,
        )

        logger.debug(f"Modbus request: {request.hex()}")

        # === Layer 2: Transport - Send and receive ===
        try:
            response_frame = self.transport.send_frame(request, timeout=5.0)
        except Exception as e:
            raise TransportError(f"Transport error: {e}")

        logger.debug(f"Modbus response: {response_frame.hex()}")

        # === Layer 3: Protocol - Parse and normalize ===
        # Validate CRC
        if not validate_crc(response_frame):
            raise ProtocolError("CRC validation failed")

        # Parse Modbus frame
        modbus_response = parse_modbus_frame(response_frame)

        # Normalize to clean bytes
        normalized_data = normalize_modbus_response(modbus_response)

        logger.debug(
            f"Normalized payload: {normalized_data.hex()} ({len(normalized_data)} bytes)"
        )

        # === Layer 4: Parser - Parse block ===
        try:
            parsed = self.parser.parse_block(
                block_id=block_id,
                data=normalized_data,
                validate=True,
                protocol_version=self.device.protocol_version,
            )
        except Exception as e:
            raise ParserError(f"Parse error for block {block_id}: {e}")

        # Log validation warnings
        if parsed.validation and parsed.validation.warnings:
            for warning in parsed.validation.warnings:
                logger.warning(f"Block {block_id}: {warning}")

        # === Layer 5: Device Model - Update state ===
        self.device.update_from_block(parsed)

        logger.info(
            f"Block {block_id} ({parsed.name}) parsed successfully: "
            f"{len(parsed.values)} fields"
        )

        return parsed

    def read_group(
        self, group: BlockGroup, partial_ok: bool = True
    ) -> List[ParsedBlock]:
        """Read a block group.

        Args:
            group: BlockGroup to read
            partial_ok: If True (default), return partial results on failures.
                       If False, fail fast on first error.

        Returns:
            List of ParsedBlock (one per block in group)

        Raises:
            ValueError: If group not supported by this device
            TransportError/ProtocolError: If any block read fails and partial_ok=False
        """
        result = self.read_group_ex(group, partial_ok=partial_ok)
        return result.blocks

    def read_group_ex(
        self, group: BlockGroup, partial_ok: bool = False
    ) -> ReadGroupResult:
        """Read a block group with detailed error reporting.

        Args:
            group: BlockGroup to read
            partial_ok: If False (default), fail fast on first error.
                       If True, continue reading remaining blocks and collect errors.

        Returns:
            ReadGroupResult with blocks and errors

        Raises:
            ValueError: If group not supported by this device
            TransportError/ProtocolError: If any block read fails and partial_ok=False
        """
        # Get group definition from device profile
        group_name = group.value
        if group_name not in self.profile.groups:
            raise ValueError(
                f"Group '{group_name}' not supported by {self.profile.model}. "
                f"Available: {list(self.profile.groups.keys())}"
            )

        group_def = self.profile.groups[group_name]

        logger.info(f"Reading group '{group_name}': {len(group_def.blocks)} blocks")

        # Read all blocks in group
        blocks = []
        errors = []

        for block_id in group_def.blocks:
            try:
                parsed = self.read_block(block_id)
                blocks.append(parsed)
            except Exception as e:
                logger.error(f"Failed to read block {block_id}: {e}")
                errors.append((block_id, e))

                # In strict mode (partial_ok=False), fail immediately
                if not partial_ok:
                    raise

        if errors and partial_ok:
            logger.warning(
                f"Group '{group_name}' read completed with {len(errors)} errors: "
                f"{len(blocks)}/{len(group_def.blocks)} blocks successful"
            )
        else:
            logger.info(
                f"Group '{group_name}' read complete: "
                f"{len(blocks)}/{len(group_def.blocks)} blocks successful"
            )

        return ReadGroupResult(blocks=blocks, errors=errors)

    def get_device_state(self) -> Dict:
        """Get current device state.

        Returns:
            Dict with all device attributes
        """
        return self.device.get_state()

    def get_group_state(self, group: BlockGroup) -> Dict:
        """Get state for specific block group.

        Args:
            group: BlockGroup to retrieve

        Returns:
            Dict with group-specific attributes
        """
        return self.device.get_group_state(group)

    def register_schema(self, schema):
        """Register a block schema with parser.

        Args:
            schema: BlockSchema to register
        """
        self.schema_registry.register(schema)
        self.parser.register_schema(schema)
        logger.debug(f"Registered schema: Block {schema.block_id} ({schema.name})")

    def get_available_groups(self) -> List[str]:
        """Get list of available block groups for this device.

        Returns:
            List of group names
        """
        return list(self.profile.groups.keys())

    def get_registered_schemas(self) -> Dict[int, str]:
        """Get list of registered schemas.

        Returns:
            Dict mapping block_id → schema_name
        """
        return self.parser.list_schemas()
=== КОНЕЦ ФАЙЛА: bluetti_sdk/client.py ===

=== НАЧАЛО ФАЙЛА: bluetti_sdk/client_async.py ===
"""Async facade for V2Client.

Provides async/await-friendly API while reusing sync V2Client logic.
"""

from __future__ import annotations

import asyncio
from types import TracebackType
from typing import Any, Dict, List, Optional, Type

from .client import ReadGroupResult, V2Client
from .contracts import DeviceModelInterface, V2ParserInterface
from .contracts.transport import TransportProtocol
from .devices.types import DeviceProfile
from .models.types import BlockGroup
from .protocol.v2.schema import BlockSchema
from .protocol.v2.types import ParsedBlock
from .schemas.registry import SchemaRegistry


class AsyncV2Client:
    """Async facade over sync V2Client using thread delegation.

    WARNING: This client is not thread-safe for concurrent operations on the
    same instance. Use one AsyncV2Client instance per async execution context.
    """

    def __init__(
        self,
        transport: TransportProtocol,
        profile: DeviceProfile,
        device_address: int = 1,
        parser: Optional[V2ParserInterface] = None,
        device: Optional[DeviceModelInterface] = None,
        schema_registry: Optional[SchemaRegistry] = None,
    ) -> None:
        self._sync_client = V2Client(
            transport=transport,
            profile=profile,
            device_address=device_address,
            parser=parser,
            device=device,
            schema_registry=schema_registry,
        )

    async def connect(self) -> None:
        await asyncio.to_thread(self._sync_client.connect)

    async def disconnect(self) -> None:
        await asyncio.to_thread(self._sync_client.disconnect)

    async def read_block(
        self,
        block_id: int,
        register_count: Optional[int] = None,
    ) -> ParsedBlock:
        return await asyncio.to_thread(
            self._sync_client.read_block, block_id, register_count
        )

    async def read_group(
        self, group: BlockGroup, partial_ok: bool = True
    ) -> List[ParsedBlock]:
        return await asyncio.to_thread(self._sync_client.read_group, group, partial_ok)

    async def read_group_ex(
        self, group: BlockGroup, partial_ok: bool = False
    ) -> ReadGroupResult:
        return await asyncio.to_thread(
            self._sync_client.read_group_ex, group, partial_ok
        )

    async def get_device_state(self) -> Dict[str, Any]:
        return await asyncio.to_thread(self._sync_client.get_device_state)

    async def get_group_state(self, group: BlockGroup) -> Dict[str, Any]:
        return await asyncio.to_thread(self._sync_client.get_group_state, group)

    async def register_schema(self, schema: BlockSchema) -> None:
        await asyncio.to_thread(self._sync_client.register_schema, schema)

    async def get_available_groups(self) -> List[str]:
        return await asyncio.to_thread(self._sync_client.get_available_groups)

    async def get_registered_schemas(self) -> Dict[int, str]:
        return await asyncio.to_thread(self._sync_client.get_registered_schemas)

    async def __aenter__(self) -> "AsyncV2Client":
        await self.connect()
        return self

    async def __aexit__(
        self,
        exc_type: Optional[Type[BaseException]],
        exc_val: Optional[BaseException],
        exc_tb: Optional[TracebackType],
    ) -> bool:
        await self.disconnect()
        return False
=== КОНЕЦ ФАЙЛА: bluetti_sdk/client_async.py ===

=== НАЧАЛО ФАЙЛА: bluetti_sdk/contracts/__init__.py ===
"""Layer Contracts and Interfaces

Defines strict contracts between architectural layers:
    transport → protocol → v2_parser → device_model

Each layer has clear responsibilities and does NOT leak into others.
"""

from .client import BluettiClientInterface
from .device import DeviceModelInterface
from .parser import V2ParserInterface
from .protocol import NormalizedPayload, ProtocolLayerInterface
from .transport import TransportProtocol

__all__ = [
    "BluettiClientInterface",
    "DeviceModelInterface",
    "NormalizedPayload",
    "ProtocolLayerInterface",
    "TransportProtocol",
    "V2ParserInterface",
]
=== КОНЕЦ ФАЙЛА: bluetti_sdk/contracts/__init__.py ===

=== НАЧАЛО ФАЙЛА: bluetti_sdk/contracts/client.py ===
"""Client layer contract."""

from abc import ABC, abstractmethod
from typing import TYPE_CHECKING, Any, Dict, List

if TYPE_CHECKING:
    from ..models.types import BlockGroup
    from ..protocol.v2.types import ParsedBlock


class BluettiClientInterface(ABC):
    """High-level client interface.

    Responsibilities:
    - Orchestrate layers: transport → protocol → parser → device
    - Device discovery
    - Polling loops
    - Error handling

    This is the PUBLIC API for applications.
    """

    @abstractmethod
    def connect(self) -> None:
        """Connect to device."""

    @abstractmethod
    def read_block(self, block_id: int) -> "ParsedBlock":
        """Read and parse a V2 block.

        Args:
            block_id: Block ID to read

        Returns:
            ParsedBlock with parsed data

        Flow:
            1. Build Modbus request (protocol layer)
            2. Send via transport
            3. Normalize response (protocol layer)
            4. Parse (v2_parser)
            5. Update device model
            6. Return ParsedBlock
        """

    @abstractmethod
    def read_group(
        self, group: "BlockGroup", partial_ok: bool = True
    ) -> List["ParsedBlock"]:
        """Read a block group.

        Args:
            group: BlockGroup to read
            partial_ok: If True (default), return partial results on failures.
                       If False, fail fast on first error.

        Returns:
            List of ParsedBlock (one per block in group)
        """

    @abstractmethod
    def get_device_state(self) -> Dict[str, Any]:
        """Get current device state."""
=== КОНЕЦ ФАЙЛА: bluetti_sdk/contracts/client.py ===

=== НАЧАЛО ФАЙЛА: bluetti_sdk/contracts/device.py ===
"""Device model layer contract."""

from abc import ABC, abstractmethod
from typing import TYPE_CHECKING, Any, Dict

if TYPE_CHECKING:
    from ..models.types import BlockGroup
    from ..protocol.v2.types import ParsedBlock


class DeviceModelInterface(ABC):
    """Device model interface.

    Responsibilities:
    - Store device state
    - Map ParsedBlock → device attributes
    - Provide high-level API

    Does NOT know about:
    - Byte offsets
    - Transforms
    - Modbus framing
    """

    @abstractmethod
    def update_from_block(self, parsed: "ParsedBlock") -> None:
        """Update device state from parsed block.

        Args:
            parsed: ParsedBlock from V2 parser

        This method knows how to map block data to device attributes.
        """

    @abstractmethod
    def get_state(self) -> Dict[str, Any]:
        """Get complete device state as dict."""

    @abstractmethod
    def get_group_state(self, group: "BlockGroup") -> Dict[str, Any]:
        """Get state for specific block group."""
=== КОНЕЦ ФАЙЛА: bluetti_sdk/contracts/device.py ===

=== НАЧАЛО ФАЙЛА: bluetti_sdk/contracts/parser.py ===
"""V2 Parser layer contract."""

from abc import ABC, abstractmethod
from typing import TYPE_CHECKING, Any, Dict, Optional

if TYPE_CHECKING:
    from ..protocol.v2.types import ParsedBlock


class V2ParserInterface(ABC):
    """V2 Parser interface.

    Responsibilities:
    - Parse normalized bytes using schemas
    - Apply transform pipelines
    - Validate against schema

    Does NOT know about:
    - Modbus
    - Transport
    - Device state management
    """

    @abstractmethod
    def parse_block(
        self,
        block_id: int,
        data: bytes,
        validate: bool = True,
        protocol_version: int = 2000,
    ) -> "ParsedBlock":
        """Parse a V2 block.

        Args:
            block_id: Block ID
            data: Normalized byte buffer (big-endian, no framing)
            validate: Whether to validate against schema
            protocol_version: Device protocol version

        Returns:
            ParsedBlock with parsed values

        Raises:
            ValueError: If block_id not registered or parsing fails
        """

    @abstractmethod
    def register_schema(self, schema: Any) -> None:
        """Register a block schema.

        Args:
            schema: BlockSchema to register
        """

    @abstractmethod
    def get_schema(self, block_id: int) -> Optional[Any]:
        """Get schema for block ID.

        Args:
            block_id: Block ID

        Returns:
            BlockSchema or None if not registered
        """

    @abstractmethod
    def list_schemas(self) -> Dict[int, str]:
        """List all registered schemas.

        Returns:
            Dictionary mapping block_id → schema_name
        """
=== КОНЕЦ ФАЙЛА: bluetti_sdk/contracts/parser.py ===

=== НАЧАЛО ФАЙЛА: bluetti_sdk/contracts/protocol.py ===
"""Protocol layer contract."""

from abc import ABC, abstractmethod
from dataclasses import dataclass
from typing import TYPE_CHECKING

if TYPE_CHECKING:
    from .transport import TransportProtocol


@dataclass
class NormalizedPayload:
    """Normalized payload ready for parsing.

    This is the CONTRACT between protocol layer and parser.
    """

    block_id: int
    data: bytes  # Big-endian, no framing
    device_address: int
    protocol_version: int = 2000


class ProtocolLayerInterface(ABC):
    """Protocol layer interface.

    Responsibilities:
    - Modbus framing/unframing
    - CRC validation
    - Byte normalization (big-endian)

    Does NOT know about:
    - Block schemas
    - Field parsing
    - Device models
    """

    @abstractmethod
    def read_block(
        self,
        transport: "TransportProtocol",
        device_address: int,
        block_id: int,
        register_count: int,
    ) -> NormalizedPayload:
        """Read a V2 block via Modbus.

        Args:
            transport: Transport layer to use
            device_address: Modbus device address
            block_id: V2 block address
            register_count: Number of registers to read

        Returns:
            NormalizedPayload with clean bytes

        Raises:
            ProtocolError: If Modbus error or CRC mismatch
        """
=== КОНЕЦ ФАЙЛА: bluetti_sdk/contracts/protocol.py ===

=== НАЧАЛО ФАЙЛА: bluetti_sdk/contracts/transport.py ===
"""Transport layer contract."""

from abc import ABC, abstractmethod


class TransportProtocol(ABC):
    """Transport layer interface.

    Responsibilities:
    - Send/receive raw frames over wire (MQTT, BLE, Serial)
    - Connection management
    - Retries and timeouts

    Does NOT know about:
    - Modbus framing
    - Block schemas
    - Device models
    """

    @abstractmethod
    def send_frame(self, frame: bytes, timeout: float = 5.0) -> bytes:
        """Send frame and wait for response.

        Args:
            frame: Raw frame to send (complete with framing/CRC)
            timeout: Timeout in seconds

        Returns:
            Raw response frame

        Raises:
            TimeoutError: If no response within timeout
            ConnectionError: If connection lost
        """

    @abstractmethod
    def connect(self) -> None:
        """Establish connection to device."""

    @abstractmethod
    def disconnect(self) -> None:
        """Close connection to device."""

    @abstractmethod
    def is_connected(self) -> bool:
        """Check if connected."""
=== КОНЕЦ ФАЙЛА: bluetti_sdk/contracts/transport.py ===

=== НАЧАЛО ФАЙЛА: bluetti_sdk/devices/profiles/__init__.py ===
"""Device Profiles Package

Device-specific configurations organized by model.

Each model has its own module with profile definition.
The registry module provides access to all profiles.

Usage:
    from bluetti_sdk.devices.profiles import get_device_profile

    profile = get_device_profile("EL100V2")
    print(profile.description)
"""

from .common import V2_BLOCK_GROUPS
from .el30v2 import EL30V2_PROFILE
from .el100v2 import EL100V2_PROFILE
from .elite200v2 import ELITE200_V2_PROFILE
from .registry import (
    DEVICE_PROFILES,
    get_device_profile,
    is_v2_device,
    list_device_models,
)

__all__ = [
    "DEVICE_PROFILES",
    "EL30V2_PROFILE",
    "EL100V2_PROFILE",
    "ELITE200_V2_PROFILE",
    "V2_BLOCK_GROUPS",
    "get_device_profile",
    "is_v2_device",
    "list_device_models",
]
=== КОНЕЦ ФАЙЛА: bluetti_sdk/devices/profiles/__init__.py ===

=== НАЧАЛО ФАЙЛА: bluetti_sdk/devices/profiles/common.py ===
"""Common V2 Block Group Definitions

Shared block groups used across different V2 device models.
"""

from ..types import BlockGroupDefinition

# ============================================================================
# V2 Block Group Definitions
# ============================================================================

V2_BLOCK_GROUPS = {
    "core": BlockGroupDefinition(
        name="core",
        blocks=[100],
        description="Main dashboard (SOC, power flows, energy)",
        poll_interval=5,
    ),
    "grid": BlockGroupDefinition(
        name="grid",
        blocks=[1300],
        description="Grid voltage, frequency, power",
        poll_interval=5,
    ),
    "battery": BlockGroupDefinition(
        name="battery",
        blocks=[6000],
        description="Battery pack status",
        poll_interval=10,
    ),
    "cells": BlockGroupDefinition(
        name="cells",
        blocks=[6100],
        description="Individual cell voltages/temps (expensive!)",
        poll_interval=60,  # Poll rarely
    ),
    "inverter": BlockGroupDefinition(
        name="inverter",
        blocks=[1100, 1400, 1500],
        description="Inverter details",
        poll_interval=10,
    ),
}
=== КОНЕЦ ФАЙЛА: bluetti_sdk/devices/profiles/common.py ===

=== НАЧАЛО ФАЙЛА: bluetti_sdk/devices/profiles/el100v2.py ===
"""Elite 100 V2 Device Profile

Bluetti Elite 100 V2: 1056Wh, 51.2V, 1000W inverter
"""

from ..types import DeviceProfile
from .common import V2_BLOCK_GROUPS

EL100V2_PROFILE = DeviceProfile(
    model="EL100V2",
    type_id="31",
    protocol="v2",
    description="Bluetti Elite 100 V2 (1056Wh, 51.2V, 1000W inverter)",
    groups={
        "core": V2_BLOCK_GROUPS["core"],
        "grid": V2_BLOCK_GROUPS["grid"],
        "battery": V2_BLOCK_GROUPS["battery"],
        "cells": V2_BLOCK_GROUPS["cells"],
        "inverter": V2_BLOCK_GROUPS["inverter"],
    },
)
=== КОНЕЦ ФАЙЛА: bluetti_sdk/devices/profiles/el100v2.py ===

=== НАЧАЛО ФАЙЛА: bluetti_sdk/devices/profiles/el30v2.py ===
"""Elite 30 V2 Device Profile

Bluetti Elite 30 V2: 336Wh, 25.6V, 600W inverter
"""

from ..types import DeviceProfile
from .common import V2_BLOCK_GROUPS

EL30V2_PROFILE = DeviceProfile(
    model="EL30V2",
    type_id="32",
    protocol="v2",
    description="Bluetti Elite 30 V2 (336Wh, 25.6V, 600W inverter)",
    groups={
        "core": V2_BLOCK_GROUPS["core"],
        "grid": V2_BLOCK_GROUPS["grid"],
        "battery": V2_BLOCK_GROUPS["battery"],
    },
)
=== КОНЕЦ ФАЙЛА: bluetti_sdk/devices/profiles/el30v2.py ===

=== НАЧАЛО ФАЙЛА: bluetti_sdk/devices/profiles/elite200v2.py ===
"""Elite 200 V2 Device Profile

Bluetti Elite 200 V2: 2073.6Wh, 51.2V, 2400W inverter
"""

from ..types import DeviceProfile
from .common import V2_BLOCK_GROUPS

ELITE200_V2_PROFILE = DeviceProfile(
    model="Elite 200 V2",
    type_id="8",
    protocol="v2",
    description="Bluetti Elite 200 V2 (2073.6Wh, 51.2V, 2400W inverter)",
    groups={
        "core": V2_BLOCK_GROUPS["core"],
        "grid": V2_BLOCK_GROUPS["grid"],
        "battery": V2_BLOCK_GROUPS["battery"],
    },
)
=== КОНЕЦ ФАЙЛА: bluetti_sdk/devices/profiles/elite200v2.py ===

=== НАЧАЛО ФАЙЛА: bluetti_sdk/devices/profiles/registry.py ===
"""Device Profile Registry

Central registry for all device profiles.
"""

from typing import Dict

from ..types import DeviceProfile
from .el30v2 import EL30V2_PROFILE
from .el100v2 import EL100V2_PROFILE
from .elite200v2 import ELITE200_V2_PROFILE

# ============================================================================
# Device Registry
# ============================================================================

DEVICE_PROFILES: Dict[str, DeviceProfile] = {
    # Elite V2 series
    "EL30V2": EL30V2_PROFILE,
    "EL100V2": EL100V2_PROFILE,
    "Elite 200 V2": ELITE200_V2_PROFILE,
    # Aliases
    "Elite 30 V2": EL30V2_PROFILE,
    "Elite 100 V2": EL100V2_PROFILE,
}


def get_device_profile(model: str) -> DeviceProfile:
    """Get device profile by model name.

    Args:
        model: Device model name

    Returns:
        DeviceProfile

    Raises:
        ValueError: If model not found
    """
    if model not in DEVICE_PROFILES:
        raise ValueError(
            f"Unknown device model: {model}. Available: {list(DEVICE_PROFILES.keys())}"
        )

    return DEVICE_PROFILES[model]


def is_v2_device(model: str) -> bool:
    """Check if device uses V2 protocol.

    Args:
        model: Device model name

    Returns:
        True if V2 device
    """
    try:
        profile = get_device_profile(model)
        return profile.protocol == "v2"
    except ValueError:
        return False


def list_device_models() -> list[str]:
    """List all available device models.

    Returns:
        List of device model names
    """
    return list(DEVICE_PROFILES.keys())
=== КОНЕЦ ФАЙЛА: bluetti_sdk/devices/profiles/registry.py ===

=== НАЧАЛО ФАЙЛА: bluetti_sdk/devices/types.py ===
"""Device configuration types."""

from dataclasses import dataclass
from typing import Dict, List


@dataclass
class BlockGroupDefinition:
    """Definition of a block group."""

    name: str
    blocks: List[int]  # Block IDs in this group
    description: str
    poll_interval: int = 5  # Recommended poll interval (seconds)


@dataclass
class DeviceProfile:
    """Device-specific configuration.

    This is configuration data, not code.
    """

    model: str
    type_id: str
    protocol: str  # "v1" or "v2"
    groups: Dict[str, BlockGroupDefinition]  # Available groups
    description: str
=== КОНЕЦ ФАЙЛА: bluetti_sdk/devices/types.py ===

=== НАЧАЛО ФАЙЛА: bluetti_sdk/errors.py ===
"""Bluetti SDK Error Hierarchy

All errors inherit from BluettiError for easy catching.
Each layer has its own error type for precise handling.
"""


class BluettiError(Exception):
    """Base error for all Bluetti SDK errors."""


class TransportError(BluettiError):
    """Transport layer error (connection, timeout, network issues)."""


class ProtocolError(BluettiError):
    """Protocol layer error (CRC, framing, invalid Modbus response)."""


class ParserError(BluettiError):
    """Parser layer error (unknown block, validation failure, schema issues)."""


class DeviceError(BluettiError):
    """Device layer error (invalid state, unsupported operation)."""
=== КОНЕЦ ФАЙЛА: bluetti_sdk/errors.py ===

=== НАЧАЛО ФАЙЛА: bluetti_sdk/models/__init__.py ===
"""Device models and state.

This module contains device state models:
- V2Device: Main device state model
- GridInfo: Grid status data
- HomeData: Home dashboard data
- BatteryPackInfo: Battery pack status

Note: Device profiles are in bluetti_sdk.devices.profiles
"""

from .device import BatteryPackInfo, GridInfo, HomeData, V2Device

__all__ = [
    "BatteryPackInfo",
    "GridInfo",
    "HomeData",
    "V2Device",
]
=== КОНЕЦ ФАЙЛА: bluetti_sdk/models/__init__.py ===

=== НАЧАЛО ФАЙЛА: bluetti_sdk/models/device.py ===
"""V2 Device Model

Device state management for V2 protocol devices.
Maps ParsedBlock → device attributes without knowing about bytes/offsets.
"""

import logging
from dataclasses import dataclass
from datetime import datetime
from typing import Any, Dict, Optional

from ..contracts.device import DeviceModelInterface
from ..protocol.v2.types import ParsedBlock
from .types import BlockGroup

logger = logging.getLogger(__name__)


@dataclass
class GridInfo:
    """Grid input information (Block 1300)."""

    frequency: Optional[float] = None  # Hz
    phase_0_voltage: Optional[float] = None  # V
    phase_0_current: Optional[float] = None  # A
    phase_0_power: Optional[int] = None  # W

    # Optional: 3-phase systems
    phase_1_voltage: Optional[float] = None
    phase_2_voltage: Optional[float] = None

    # Energy counters
    total_charge_energy: Optional[int] = None  # Wh
    total_feedback_energy: Optional[int] = None  # Wh

    # Metadata
    last_update: Optional[datetime] = None


@dataclass
class HomeData:
    """Main dashboard data (Block 100)."""

    # Battery
    soc: Optional[int] = None  # %
    pack_voltage: Optional[float] = None  # V
    pack_current: Optional[float] = None  # A
    pack_power: Optional[int] = None  # W
    soh: Optional[int] = None  # %

    # Temperatures
    pack_temp_avg: Optional[int] = None  # °C
    pack_temp_max: Optional[int] = None  # °C
    pack_temp_min: Optional[int] = None  # °C

    # Power flows
    dc_input_power: Optional[int] = None  # W
    ac_input_power: Optional[int] = None  # W
    ac_output_power: Optional[int] = None  # W

    # PV
    pv_power: Optional[int] = None  # W
    pv1_voltage: Optional[float] = None  # V
    pv1_current: Optional[float] = None  # A
    pv2_voltage: Optional[float] = None  # V
    pv2_current: Optional[float] = None  # A

    # Grid
    grid_power: Optional[int] = None  # W (negative = export)

    # Load
    load_power: Optional[int] = None  # W

    # Energy totals
    total_energy_charge: Optional[int] = None  # Wh
    total_energy_discharge: Optional[int] = None  # Wh

    # Metadata
    last_update: Optional[datetime] = None


@dataclass
class BatteryPackInfo:
    """Battery pack information (Block 6000)."""

    soc: Optional[int] = None  # %
    voltage: Optional[float] = None  # V
    current: Optional[float] = None  # A
    power: Optional[int] = None  # W

    temp_max: Optional[int] = None  # °C
    temp_min: Optional[int] = None  # °C
    temp_avg: Optional[int] = None  # °C

    cycles: Optional[int] = None
    soh: Optional[int] = None  # %

    cell_count: Optional[int] = None

    # Status
    charging: Optional[bool] = None
    discharging: Optional[bool] = None

    # Metadata
    last_update: Optional[datetime] = None


class V2Device(DeviceModelInterface):
    """V2 protocol device model.

    Stores parsed data from V2 blocks and provides high-level API.
    Does NOT know about byte offsets, transforms, or Modbus.
    """

    def __init__(self, device_id: str, model: str, protocol_version: int = 2000):
        """Initialize V2 device.

        Args:
            device_id: Device serial number or identifier
            model: Device model (e.g., "EL100V2")
            protocol_version: Protocol version (default: 2000)
        """
        self.device_id = device_id
        self.model = model
        self.protocol_version = protocol_version

        # State containers (one per block group)
        self.grid_info = GridInfo()
        self.home_data = HomeData()
        self.battery_pack = BatteryPackInfo()

        # Raw block storage (for debugging)
        self._blocks: Dict[int, ParsedBlock] = {}

        # Last update timestamp
        self.last_update: Optional[datetime] = None

    def update_from_block(self, parsed: ParsedBlock):
        """Update device state from parsed block.

        Maps ParsedBlock.values → device attributes based on block_id.
        This is the ONLY place that knows block_id → attribute mapping.

        Args:
            parsed: ParsedBlock from V2 parser
        """
        # Store raw block
        self._blocks[parsed.block_id] = parsed
        self.last_update = datetime.now()

        # Dispatch to specific update method based on block_id
        if parsed.block_id == 100:
            self._update_home_data(parsed)
        elif parsed.block_id == 1300:
            self._update_grid_info(parsed)
        elif parsed.block_id == 6000:
            self._update_battery_pack(parsed)
        else:
            logger.warning(f"Unknown block {parsed.block_id} ({parsed.name})")

    def _update_home_data(self, parsed: ParsedBlock):
        """Update home data from Block 100."""
        values = parsed.values

        # Battery
        self.home_data.soc = values.get("soc")
        self.home_data.pack_voltage = values.get("pack_voltage")
        self.home_data.pack_current = values.get("pack_current")
        self.home_data.pack_power = values.get("pack_power")
        self.home_data.soh = values.get("soh")

        # Temperatures
        self.home_data.pack_temp_avg = values.get("pack_temp_avg")
        self.home_data.pack_temp_max = values.get("pack_temp_max")
        self.home_data.pack_temp_min = values.get("pack_temp_min")

        # Power flows
        self.home_data.dc_input_power = values.get("dc_input_power")
        self.home_data.ac_input_power = values.get("ac_input_power")
        self.home_data.ac_output_power = values.get("ac_output_power")

        # PV
        self.home_data.pv_power = values.get("pv_power")
        self.home_data.pv1_voltage = values.get("pv1_voltage")
        self.home_data.pv1_current = values.get("pv1_current")
        self.home_data.pv2_voltage = values.get("pv2_voltage")
        self.home_data.pv2_current = values.get("pv2_current")

        # Grid
        self.home_data.grid_power = values.get("grid_power")

        # Load
        self.home_data.load_power = values.get("load_power")

        # Energy totals
        self.home_data.total_energy_charge = values.get("total_energy_charge")
        self.home_data.total_energy_discharge = values.get("total_energy_discharge")

        self.home_data.last_update = datetime.now()

        logger.debug(f"Updated home_data: SOC={self.home_data.soc}%")

    def _update_grid_info(self, parsed: ParsedBlock):
        """Update grid info from Block 1300."""
        values = parsed.values

        self.grid_info.frequency = values.get("frequency")
        self.grid_info.phase_0_voltage = values.get("phase_0_voltage")
        self.grid_info.phase_0_current = values.get("phase_0_current")
        self.grid_info.phase_0_power = values.get("phase_0_power")

        # Optional 3-phase
        self.grid_info.phase_1_voltage = values.get("phase_1_voltage")
        self.grid_info.phase_2_voltage = values.get("phase_2_voltage")

        # Energy counters
        self.grid_info.total_charge_energy = values.get("total_charge_energy")
        self.grid_info.total_feedback_energy = values.get("total_feedback_energy")

        self.grid_info.last_update = datetime.now()

        logger.debug(
            f"Updated grid_info: {self.grid_info.phase_0_voltage}V @ "
            f"{self.grid_info.frequency}Hz"
        )

    def _update_battery_pack(self, parsed: ParsedBlock):
        """Update battery pack from Block 6000."""
        values = parsed.values

        self.battery_pack.soc = values.get("soc")
        self.battery_pack.voltage = values.get("voltage")
        self.battery_pack.current = values.get("current")
        self.battery_pack.power = values.get("power")

        self.battery_pack.temp_max = values.get("temp_max")
        self.battery_pack.temp_min = values.get("temp_min")
        self.battery_pack.temp_avg = values.get("temp_avg")

        self.battery_pack.cycles = values.get("cycles")
        self.battery_pack.soh = values.get("soh")
        self.battery_pack.cell_count = values.get("cell_count")

        # Status flags
        self.battery_pack.charging = values.get("charging")
        self.battery_pack.discharging = values.get("discharging")

        self.battery_pack.last_update = datetime.now()

        logger.debug(f"Updated battery_pack: SOC={self.battery_pack.soc}%")

    def get_state(self) -> Dict[str, Any]:
        """Get complete device state as flat dict.

        Returns:
            Dict with all device attributes (for MQTT/JSON)
        """
        state = {
            "device_id": self.device_id,
            "model": self.model,
            "protocol_version": self.protocol_version,
            "last_update": self.last_update.isoformat() if self.last_update else None,
        }

        # Grid info
        if self.grid_info.last_update:
            state.update(
                {
                    "grid_frequency": self.grid_info.frequency,
                    "grid_voltage": self.grid_info.phase_0_voltage,
                    "grid_current": self.grid_info.phase_0_current,
                    "grid_power": self.grid_info.phase_0_power,
                }
            )

        # Home data
        if self.home_data.last_update:
            state.update(
                {
                    "soc": self.home_data.soc,
                    "pack_voltage": self.home_data.pack_voltage,
                    "pack_current": self.home_data.pack_current,
                    "pack_power": self.home_data.pack_power,
                    "soh": self.home_data.soh,
                    "pack_temp_avg": self.home_data.pack_temp_avg,
                    "dc_input_power": self.home_data.dc_input_power,
                    "ac_input_power": self.home_data.ac_input_power,
                    "ac_output_power": self.home_data.ac_output_power,
                    "pv_power": self.home_data.pv_power,
                    "grid_power": self.home_data.grid_power,
                    "load_power": self.home_data.load_power,
                }
            )

        # Battery pack
        if self.battery_pack.last_update:
            state.update(
                {
                    "battery_soc": self.battery_pack.soc,
                    "battery_voltage": self.battery_pack.voltage,
                    "battery_current": self.battery_pack.current,
                    "battery_cycles": self.battery_pack.cycles,
                }
            )

        return state

    def get_group_state(self, group: BlockGroup) -> Dict[str, Any]:
        """Get state for specific block group.

        Args:
            group: BlockGroup to retrieve

        Returns:
            Dict with group-specific attributes
        """
        if group == BlockGroup.GRID:
            return {
                "frequency": self.grid_info.frequency,
                "voltage": self.grid_info.phase_0_voltage,
                "current": self.grid_info.phase_0_current,
                "power": self.grid_info.phase_0_power,
                "last_update": self.grid_info.last_update.isoformat()
                if self.grid_info.last_update
                else None,
            }

        elif group == BlockGroup.CORE:
            return {
                "soc": self.home_data.soc,
                "pack_voltage": self.home_data.pack_voltage,
                "pack_current": self.home_data.pack_current,
                "pack_power": self.home_data.pack_power,
                "last_update": self.home_data.last_update.isoformat()
                if self.home_data.last_update
                else None,
            }

        elif group == BlockGroup.BATTERY:
            return {
                "soc": self.battery_pack.soc,
                "voltage": self.battery_pack.voltage,
                "current": self.battery_pack.current,
                "cycles": self.battery_pack.cycles,
                "soh": self.battery_pack.soh,
                "last_update": self.battery_pack.last_update.isoformat()
                if self.battery_pack.last_update
                else None,
            }

        else:
            logger.warning(f"Unknown group: {group}")
            return {}

    def get_raw_block(self, block_id: int) -> Optional[ParsedBlock]:
        """Get raw ParsedBlock for debugging.

        Args:
            block_id: Block ID

        Returns:
            ParsedBlock or None if not available
        """
        return self._blocks.get(block_id)
=== КОНЕЦ ФАЙЛА: bluetti_sdk/models/device.py ===

=== НАЧАЛО ФАЙЛА: bluetti_sdk/models/types.py ===
"""Domain model types."""

from enum import Enum


class BlockGroup(Enum):
    """V2 block groups."""

    CORE = "core"  # Block 100 - Dashboard
    GRID = "grid"  # Block 1300 - Grid input
    BATTERY = "battery"  # Block 6000 - Battery pack
    CELLS = "cells"  # Block 6100 - Cell details
    INVERTER = "inverter"  # Blocks 1100, 1400, 1500
=== КОНЕЦ ФАЙЛА: bluetti_sdk/models/types.py ===

=== НАЧАЛО ФАЙЛА: bluetti_sdk/protocol/__init__.py ===
"""Protocol layer - Modbus and V2 protocol implementations.

This module contains:
- Modbus RTU normalization and framing
- V2 protocol parser with schema-based field extraction
"""

from .modbus import (
    ModbusResponse,
    build_modbus_request,
    normalize_modbus_response,
    parse_modbus_frame,
    validate_crc,
)

__all__ = [
    "ModbusResponse",
    "build_modbus_request",
    "normalize_modbus_response",
    "parse_modbus_frame",
    "validate_crc",
]
=== КОНЕЦ ФАЙЛА: bluetti_sdk/protocol/__init__.py ===

=== НАЧАЛО ФАЙЛА: bluetti_sdk/protocol/modbus.py ===
"""Protocol Layer - Modbus RTU Normalization

Responsibilities:
- Convert Modbus responses to normalized byte buffers
- Handle Modbus framing (function code, byte count)
- CRC validation (if needed)
- Endianness conversion

Does NOT know about:
- Block schemas
- Field parsing
- Transform pipelines
- Device models
"""

import logging
import struct
from dataclasses import dataclass
from typing import Optional

from ..errors import ProtocolError

logger = logging.getLogger(__name__)


@dataclass
class ModbusResponse:
    """Raw Modbus response before normalization."""

    device_address: int
    function_code: int
    byte_count: int
    data: bytes
    crc: Optional[int] = None


def normalize_modbus_response(response: ModbusResponse) -> bytes:
    """Convert Modbus response to normalized byte buffer.

    Input: Raw Modbus response with framing
    Output: Clean big-endian byte buffer ready for parser

    Responsibilities:
    - Remove function code byte
    - Remove byte count
    - Keep only register data
    - Ensure big-endian byte order

    Args:
        response: ModbusResponse with framing

    Returns:
        Normalized byte buffer (big-endian, no framing)

    Raises:
        ProtocolError: If response is invalid

    Example:
        Raw Modbus response: 01 03 06 00 55 02 08 0C AD CRC
                             ^  ^  ^  [---- data ----]
                             |  |  |
                             |  |  byte_count
                             |  function_code
                             device_address

        Normalized: 00 55 02 08 0C AD (6 bytes, big-endian)
    """
    # Check for error response (function code has high bit set)
    if response.function_code & 0x80:
        if len(response.data) == 0:
            raise ProtocolError("Malformed Modbus error response: missing error code")

        error_code = response.data[0]
        error_names = {
            0x01: "Illegal function",
            0x02: "Illegal data address",
            0x03: "Illegal data value",
            0x04: "Slave device failure",
        }
        error_name = error_names.get(error_code, f"Unknown error {error_code}")
        raise ProtocolError(f"Modbus error response: {error_name} (code {error_code})")

    # Validate function code (0x03 = Read Holding Registers)
    if response.function_code != 0x03:
        raise ProtocolError(
            f"Unsupported function code: 0x{response.function_code:02X} "
            f"(expected 0x03 for Read Holding Registers)"
        )

    # Validate byte count
    if response.byte_count != len(response.data):
        raise ProtocolError(
            f"Byte count mismatch: header says {response.byte_count}, "
            f"but got {len(response.data)} bytes"
        )

    # Data is already big-endian from Modbus
    # Just return clean payload
    return response.data


def parse_modbus_frame(frame: bytes) -> ModbusResponse:
    """Parse raw Modbus frame into ModbusResponse.

    Args:
        frame: Raw Modbus RTU frame with framing

    Returns:
        ModbusResponse object

    Raises:
        ProtocolError: If frame is invalid

    Frame format:
        [device_addr][func_code][byte_count][data...][crc_low][crc_high]
         1 byte       1 byte     1 byte      N bytes  2 bytes
    """
    if len(frame) < 5:
        raise ProtocolError(f"Frame too short: {len(frame)} bytes")

    device_address = frame[0]
    function_code = frame[1]
    byte_count = frame[2]

    # Extract data (between byte_count and CRC)
    data_start = 3
    data_end = 3 + byte_count

    if len(frame) < data_end + 2:
        raise ProtocolError(
            f"Frame truncated: expected {data_end + 2} bytes, got {len(frame)}"
        )

    data = frame[data_start:data_end]

    # Extract CRC (optional - for validation)
    crc_bytes = frame[data_end : data_end + 2]
    crc = struct.unpack("<H", crc_bytes)[0] if len(crc_bytes) == 2 else None

    return ModbusResponse(
        device_address=device_address,
        function_code=function_code,
        byte_count=byte_count,
        data=data,
        crc=crc,
    )


def build_modbus_request(
    device_address: int, block_address: int, register_count: int
) -> bytes:
    """Build Modbus Read Holding Registers request.

    Args:
        device_address: Modbus device address (usually 1)
        block_address: Starting register address
        register_count: Number of registers to read

    Returns:
        Complete Modbus RTU frame with CRC

    Format:
        [device_addr][func_code=0x03][start_addr_hi][start_addr_lo][count_hi][count_lo][crc_lo][crc_hi]
    """
    # Build frame without CRC
    frame = bytearray()
    frame.append(device_address)
    frame.append(0x03)  # Read Holding Registers
    frame.extend(struct.pack(">H", block_address))  # Big-endian address
    frame.extend(struct.pack(">H", register_count))  # Big-endian count

    # Calculate CRC16-Modbus
    crc = _calculate_crc16_modbus(frame)
    frame.extend(struct.pack("<H", crc))  # Little-endian CRC

    return bytes(frame)


def _calculate_crc16_modbus(data: bytes) -> int:
    """Calculate CRC16-Modbus (little-endian polynomial).

    Args:
        data: Data to calculate CRC for

    Returns:
        CRC16 value
    """
    crc = 0xFFFF

    for byte in data:
        crc ^= byte
        for _ in range(8):
            if crc & 0x0001:
                crc = (crc >> 1) ^ 0xA001
            else:
                crc >>= 1

    return crc


def validate_crc(frame: bytes) -> bool:
    """Validate Modbus CRC.

    Args:
        frame: Complete Modbus frame with CRC

    Returns:
        True if CRC is valid
    """
    if len(frame) < 4:
        return False

    # Extract CRC from frame
    received_crc = struct.unpack("<H", frame[-2:])[0]

    # Calculate CRC of frame without CRC bytes
    calculated_crc = _calculate_crc16_modbus(frame[:-2])

    return received_crc == calculated_crc
=== КОНЕЦ ФАЙЛА: bluetti_sdk/protocol/modbus.py ===

=== НАЧАЛО ФАЙЛА: bluetti_sdk/protocol/v2/__init__.py ===
"""V2 Protocol - Schema-based parser for Elite V2 devices.

This module implements a declarative, data-driven parser for V2 protocol blocks.

Architecture:
    - DataTypes: Type system (UInt8/16/32, Int8/16/32, String, Bitmap, Enum)
    - Transforms: Transform pipeline (abs, scale, minus, bitmask, shift, clamp)
    - Schema: Field definitions (Field, ArrayField, PackedField, BlockSchema)
    - Parser: V2Parser engine

Example:
    >>> from bluetti_sdk.protocol.v2 import V2Parser, BlockSchema, Field, UInt16
    >>>
    >>> schema = BlockSchema(
    ...     block_id=1300,
    ...     name="GRID_INFO",
    ...     min_length=32,
    ...     fields=[
    ...         Field("frequency", offset=0, type=UInt16(),
    ...               transform=["scale:0.1"], unit="Hz"),
    ...         Field("voltage", offset=28, type=UInt16(),
    ...               transform=["scale:0.1"], unit="V"),
    ...     ]
    ... )
    >>>
    >>> parser = V2Parser()
    >>> parser.register_schema(schema)
    >>> parsed = parser.parse_block(1300, data_bytes)
    >>> print(parsed.values['frequency'])  # 50.0
"""

# DataTypes
from .datatypes import (
    Bitmap,
    DataType,
    Enum,
    Int8,
    Int16,
    Int32,
    String,
    UInt8,
    UInt16,
    UInt32,
)

# Parser
from .parser import V2Parser

# Schema
from .schema import (
    ArrayField,
    BlockSchema,
    Field,
    PackedField,
    SubField,
)

# Transforms
from .transforms import (
    TransformChain,
    TransformStep,
    abs_,
    bitmask,
    clamp,
    compile_transform_pipeline,
    minus,
    scale,
    shift,
)
from .types import ParsedBlock

__all__ = [
    # DataTypes
    "DataType",
    "UInt8",
    "UInt16",
    "UInt32",
    "Int8",
    "Int16",
    "Int32",
    "String",
    "Bitmap",
    "Enum",
    # Transforms
    "TransformStep",
    "TransformChain",
    "compile_transform_pipeline",
    "abs_",
    "scale",
    "minus",
    "bitmask",
    "shift",
    "clamp",
    # Schema
    "Field",
    "ArrayField",
    "PackedField",
    "SubField",
    "BlockSchema",
    # Parser
    "V2Parser",
    "ParsedBlock",
]
=== КОНЕЦ ФАЙЛА: bluetti_sdk/protocol/v2/__init__.py ===

=== НАЧАЛО ФАЙЛА: bluetti_sdk/protocol/v2/datatypes.py ===
"""V2 Protocol Data Types

Base types for parsing V2 protocol blocks.
All types parse from normalized big-endian byte buffers.
"""

import struct
from abc import ABC, abstractmethod
from dataclasses import dataclass
from types import MappingProxyType
from typing import Any, Mapping, Optional


class DataType(ABC):
    """Base class for V2 protocol data types."""

    @abstractmethod
    def parse(self, data: bytes, offset: int) -> Any:
        """Parse value from normalized byte buffer.

        Args:
            data: Normalized byte buffer (big-endian, no Modbus framing)
            offset: Byte offset to start parsing

        Returns:
            Parsed value

        Raises:
            IndexError: If offset + size exceeds data length
            ValueError: If data is invalid for this type
        """

    @abstractmethod
    def size(self) -> int:
        """Size in bytes."""

    @abstractmethod
    def encode(self, value: Any) -> bytes:
        """Encode value for writing.

        Args:
            value: Value to encode

        Returns:
            Encoded bytes (big-endian)

        Raises:
            ValueError: If value is invalid for this type
        """


class UInt8(DataType):
    """8-bit unsigned integer (0-255)."""

    def parse(self, data: bytes, offset: int) -> int:
        if offset + 1 > len(data):
            raise IndexError(
                f"UInt8 at offset {offset} exceeds data length {len(data)}"
            )
        return data[offset]

    def size(self) -> int:
        return 1

    def encode(self, value: int) -> bytes:
        if not 0 <= value <= 255:
            raise ValueError(f"UInt8 value {value} out of range [0, 255]")
        return bytes([value])


class Int8(DataType):
    """8-bit signed integer (-128 to 127)."""

    def parse(self, data: bytes, offset: int) -> int:
        if offset + 1 > len(data):
            raise IndexError(f"Int8 at offset {offset} exceeds data length {len(data)}")
        return struct.unpack_from(">b", data, offset)[0]

    def size(self) -> int:
        return 1

    def encode(self, value: int) -> bytes:
        if not -128 <= value <= 127:
            raise ValueError(f"Int8 value {value} out of range [-128, 127]")
        return struct.pack(">b", value)


class UInt16(DataType):
    """16-bit unsigned integer, big-endian (0-65535)."""

    def parse(self, data: bytes, offset: int) -> int:
        if offset + 2 > len(data):
            raise IndexError(
                f"UInt16 at offset {offset} exceeds data length {len(data)}"
            )
        return struct.unpack_from(">H", data, offset)[0]

    def size(self) -> int:
        return 2

    def encode(self, value: int) -> bytes:
        if not 0 <= value <= 65535:
            raise ValueError(f"UInt16 value {value} out of range [0, 65535]")
        return struct.pack(">H", value)


class Int16(DataType):
    """16-bit signed integer, big-endian (-32768 to 32767)."""

    def parse(self, data: bytes, offset: int) -> int:
        if offset + 2 > len(data):
            raise IndexError(
                f"Int16 at offset {offset} exceeds data length {len(data)}"
            )
        return struct.unpack_from(">h", data, offset)[0]

    def size(self) -> int:
        return 2

    def encode(self, value: int) -> bytes:
        if not -32768 <= value <= 32767:
            raise ValueError(f"Int16 value {value} out of range [-32768, 32767]")
        return struct.pack(">h", value)


class UInt32(DataType):
    """32-bit unsigned integer, big-endian (0-4294967295)."""

    def parse(self, data: bytes, offset: int) -> int:
        if offset + 4 > len(data):
            raise IndexError(
                f"UInt32 at offset {offset} exceeds data length {len(data)}"
            )
        return struct.unpack_from(">I", data, offset)[0]

    def size(self) -> int:
        return 4

    def encode(self, value: int) -> bytes:
        if not 0 <= value <= 4294967295:
            raise ValueError(f"UInt32 value {value} out of range [0, 4294967295]")
        return struct.pack(">I", value)


class Int32(DataType):
    """32-bit signed integer, big-endian (-2147483648 to 2147483647)."""

    def parse(self, data: bytes, offset: int) -> int:
        if offset + 4 > len(data):
            raise IndexError(
                f"Int32 at offset {offset} exceeds data length {len(data)}"
            )
        return struct.unpack_from(">i", data, offset)[0]

    def size(self) -> int:
        return 4

    def encode(self, value: int) -> bytes:
        if not -2147483648 <= value <= 2147483647:
            raise ValueError(
                f"Int32 value {value} out of range [-2147483648, 2147483647]"
            )
        return struct.pack(">i", value)


@dataclass(frozen=True)
class String(DataType):
    """Fixed-length ASCII string (immutable)."""

    length: int

    def parse(self, data: bytes, offset: int) -> str:
        if offset + self.length > len(data):
            raise IndexError(
                f"String({self.length}) at offset {offset} exceeds data length {len(data)}"
            )

        raw = data[offset : offset + self.length]
        # Null-terminated string
        null_pos = raw.find(b"\x00")
        if null_pos >= 0:
            raw = raw[:null_pos]

        return raw.decode("ascii", errors="replace")

    def size(self) -> int:
        return self.length

    def encode(self, value: str) -> bytes:
        encoded = value.encode("ascii", errors="replace")
        if len(encoded) > self.length:
            raise ValueError(f"String '{value}' exceeds max length {self.length}")

        # Pad with nulls
        return encoded.ljust(self.length, b"\x00")


@dataclass(frozen=True)
class Bitmap(DataType):
    """Bit field type (immutable)."""

    bits: int

    def __post_init__(self):
        """Validate and compute derived attributes."""
        if self.bits not in (8, 16, 32, 64):
            raise ValueError(f"Bitmap bits must be 8, 16, 32, or 64, got {self.bits}")

        # Compute derived attributes (frozen-safe)
        object.__setattr__(self, "_bytes", self.bits // 8)

        # Select appropriate base type
        if self.bits == 8:
            base_type = UInt8()
        elif self.bits == 16:
            base_type = UInt16()
        elif self.bits == 32:
            base_type = UInt32()
        else:  # 64
            base_type = None  # Manual parsing

        object.__setattr__(self, "_base_type", base_type)

    def parse(self, data: bytes, offset: int) -> int:
        if self.bits == 64:
            # 64-bit requires manual parsing
            if offset + 8 > len(data):
                raise IndexError(
                    f"Bitmap(64) at offset {offset} exceeds data length {len(data)}"
                )
            return struct.unpack_from(">Q", data, offset)[0]
        else:
            return self._base_type.parse(data, offset)

    def size(self) -> int:
        return self._bytes

    def encode(self, value: int) -> bytes:
        max_val = (1 << self.bits) - 1
        if not 0 <= value <= max_val:
            raise ValueError(
                f"Bitmap({self.bits}) value {value} out of range [0, {max_val}]"
            )

        if self.bits == 64:
            return struct.pack(">Q", value)
        else:
            return self._base_type.encode(value)


@dataclass(frozen=True)
class Enum(DataType):
    """Enum type with integer → string mapping (immutable)."""

    mapping: Mapping[int, str]
    base_type: Optional[DataType] = None

    def __post_init__(self):
        """Make mapping immutable and compute reverse mapping."""
        # ALWAYS make defensive copy (unconditional)
        # This prevents mutation via external references, even if input is MappingProxyType
        # wrapping a mutable dict
        object.__setattr__(self, "mapping", MappingProxyType(dict(self.mapping)))

        # Compute reverse mapping (also defensive copy)
        reverse = {v: k for k, v in self.mapping.items()}
        object.__setattr__(self, "_reverse_mapping", MappingProxyType(reverse))

        # Set default base_type if not provided
        if self.base_type is None:
            object.__setattr__(self, "base_type", UInt8())

        # Validate base_type immutability (architectural defense-in-depth)
        # Strict contract: only allow SDK built-in immutable types or frozen dataclasses
        if self.base_type is not None:
            from dataclasses import is_dataclass

            base_type_class = type(self.base_type)

            # Whitelist: SDK built-in immutable types
            _ALLOWED_BASE_TYPES = (UInt8, UInt16, UInt32, Int8, Int16, Int32)

            is_builtin_immutable = isinstance(self.base_type, _ALLOWED_BASE_TYPES)
            is_frozen_dataclass = False

            if is_dataclass(base_type_class):
                # Check if dataclass is frozen via __dataclass_params__
                if hasattr(base_type_class, "__dataclass_params__"):
                    is_frozen_dataclass = base_type_class.__dataclass_params__.frozen

            if not (is_builtin_immutable or is_frozen_dataclass):
                raise ValueError(
                    f"Enum.base_type must be immutable. "
                    f"Got {base_type_class.__name__}. "
                    f"Allowed: SDK built-in types (UInt8, UInt16, UInt32, Int8, Int16, Int32) "
                    f"or custom @dataclass(frozen=True) subclasses of DataType."
                )

    def parse(self, data: bytes, offset: int) -> str:
        raw_value = self.base_type.parse(data, offset)

        # Return mapped string or "UNKNOWN_<value>"
        return self.mapping.get(raw_value, f"UNKNOWN_{raw_value}")

    def size(self) -> int:
        return self.base_type.size()

    def encode(self, value: str) -> bytes:
        if value not in self._reverse_mapping:
            raise ValueError(f"Enum value '{value}' not in mapping")

        int_value = self._reverse_mapping[value]
        return self.base_type.encode(int_value)
=== КОНЕЦ ФАЙЛА: bluetti_sdk/protocol/v2/datatypes.py ===

=== НАЧАЛО ФАЙЛА: bluetti_sdk/protocol/v2/parser.py ===
"""V2 Protocol Parser

Core parsing engine for V2 protocol blocks.
"""

import logging
import time
from typing import Dict, Optional

from ...contracts.parser import V2ParserInterface
from .schema import ArrayField, BlockSchema, Field, PackedField
from .types import ParsedBlock

logger = logging.getLogger(__name__)


class V2Parser(V2ParserInterface):
    """V2 Protocol Parser.

    Parses V2 blocks using declarative schemas.
    """

    def __init__(self):
        """Initialize V2 parser."""
        self._schemas: Dict[int, BlockSchema] = {}

    def register_schema(self, schema: BlockSchema):
        """Register a block schema.

        Args:
            schema: BlockSchema to register

        Raises:
            ValueError: If block_id already registered
        """
        if schema.block_id in self._schemas:
            raise ValueError(
                f"Block {schema.block_id} already registered "
                f"(existing: {self._schemas[schema.block_id].name})"
            )

        self._schemas[schema.block_id] = schema
        logger.debug(f"Registered schema: Block {schema.block_id} ({schema.name})")

    def get_schema(self, block_id: int) -> Optional[BlockSchema]:
        """Get schema for block ID.

        Args:
            block_id: Block ID

        Returns:
            BlockSchema or None if not registered
        """
        return self._schemas.get(block_id)

    def parse_block(
        self,
        block_id: int,
        data: bytes,
        validate: bool = True,
        protocol_version: int = 2000,
    ) -> ParsedBlock:
        """Parse a V2 block.

        Args:
            block_id: Block ID
            data: Normalized byte buffer (big-endian, no Modbus framing)
            validate: Whether to validate against schema
            protocol_version: Device protocol version

        Returns:
            ParsedBlock with parsed values and metadata

        Raises:
            ValueError: If block_id not registered or parsing fails
            ParserError: If schema validation fails in strict mode
        """
        schema = self._schemas.get(block_id)
        if not schema:
            raise ValueError(f"No schema registered for block {block_id}")

        # Validate data
        validation_result = None
        if validate:
            validation_result = schema.validate(data)

            if not validation_result.valid:
                error_msg = (
                    f"Block {block_id} ({schema.name}) validation failed: "
                    f"{validation_result.errors}"
                )

                if schema.strict:
                    # In strict mode, fail fast
                    from ...errors import ParserError

                    raise ParserError(error_msg)
                else:
                    # In non-strict mode, just warn and continue
                    logger.warning(error_msg)

        # Parse all fields
        values = {}

        for field_def in schema.fields:
            try:
                # Check if field is available (protocol version gate)
                if field_def.min_protocol_version:
                    if protocol_version < field_def.min_protocol_version:
                        logger.debug(
                            f"Skipping field '{field_def.name}' "
                            f"(requires protocol >= {field_def.min_protocol_version})"
                        )
                        values[field_def.name] = None
                        continue

                # Check if field fits in data
                field_end = field_def.offset + field_def.size()
                if field_end > len(data):
                    if field_def.required:
                        logger.warning(
                            f"Required field '{field_def.name}' at offset "
                            f"{field_def.offset} exceeds data length {len(data)}"
                        )
                    values[field_def.name] = None
                    continue

                # Parse based on field type
                if isinstance(field_def, Field) or isinstance(field_def, ArrayField):
                    values[field_def.name] = field_def.parse(data)

                elif isinstance(field_def, PackedField):
                    # PackedField uses its configured base_type
                    values[field_def.name] = field_def.parse(data)

                else:
                    logger.warning(f"Unknown field type: {type(field_def).__name__}")
                    values[field_def.name] = None

            except Exception as e:
                if field_def.required:
                    logger.error(
                        f"Error parsing required field '{field_def.name}': {e}"
                    )
                    raise ValueError(f"Failed to parse field '{field_def.name}': {e}")
                else:
                    logger.debug(f"Optional field '{field_def.name}' parse error: {e}")
                    values[field_def.name] = None

        # Create ParsedBlock
        parsed = ParsedBlock(
            block_id=block_id,
            name=schema.name,
            values=values,
            raw=data,
            length=len(data),
            protocol_version=protocol_version,
            schema_version=schema.schema_version,
            timestamp=time.time(),
            validation=validation_result,
        )

        # Log warnings if validation failed
        if validation_result and validation_result.warnings:
            for warning in validation_result.warnings:
                logger.debug(f"Block {block_id} ({schema.name}): {warning}")

        return parsed

    def list_schemas(self) -> Dict[int, str]:
        """List all registered schemas.

        Returns:
            Dictionary mapping block_id → schema_name
        """
        return {block_id: schema.name for block_id, schema in self._schemas.items()}
=== КОНЕЦ ФАЙЛА: bluetti_sdk/protocol/v2/parser.py ===

=== НАЧАЛО ФАЙЛА: bluetti_sdk/protocol/v2/schema.py ===
"""V2 Protocol Schema Definitions

Field definitions and block schemas for V2 protocol parsing.
"""

from dataclasses import dataclass
from dataclasses import field as dataclass_field
from typing import Any, Dict, List, Mapping, Optional, Sequence

from .datatypes import DataType
from .transforms import compile_transform_pipeline


@dataclass
class ValidationResult:
    """Result of schema validation."""

    valid: bool
    errors: List[str] = dataclass_field(default_factory=list)
    warnings: List[str] = dataclass_field(default_factory=list)
    missing_fields: List[str] = dataclass_field(default_factory=list)


@dataclass(frozen=True)
class Field:
    """Basic field definition.

    Represents a single value at a specific offset in a V2 block.

    Example:
        Field(
            name="soc",
            offset=0,
            type=UInt16(),
            unit="%",
            required=True
        )
    """

    name: str
    offset: int
    type: DataType
    unit: Optional[str] = None
    required: bool = True
    transform: Optional[Sequence[str]] = None
    min_protocol_version: Optional[int] = None
    description: Optional[str] = None

    def __post_init__(self):
        """Compile transform pipeline for performance."""
        # Convert to immutable tuple if list provided
        if self.transform is not None and isinstance(self.transform, list):
            object.__setattr__(self, "transform", tuple(self.transform))

        # Compile transform pipeline (frozen-safe: use object.__setattr__)
        if self.transform:
            compiled = compile_transform_pipeline(self.transform)
            object.__setattr__(self, "_compiled_transform", compiled)
        else:
            object.__setattr__(self, "_compiled_transform", None)

    def parse(self, data: bytes) -> Any:
        """Parse field value from data.

        Args:
            data: Normalized byte buffer

        Returns:
            Parsed and transformed value

        Raises:
            IndexError: If offset + size exceeds data length
            ValueError: If parsing fails
        """
        # Parse raw value
        raw_value = self.type.parse(data, self.offset)

        # Apply transforms
        if self._compiled_transform:
            return self._compiled_transform(raw_value)

        return raw_value

    def size(self) -> int:
        """Field size in bytes."""
        return self.type.size()


@dataclass(frozen=True)
class ArrayField:
    """Array field definition.

    Represents multiple values of the same type at regular intervals.

    Example:
        ArrayField(
            name="cell_voltages",
            offset=10,
            count=16,
            stride=2,
            item_type=UInt16(),
            transform=["bitmask:0x3FFF", "scale:0.001"],
            unit="V"
        )
    """

    name: str
    offset: int
    count: int
    stride: int
    item_type: DataType
    unit: Optional[str] = None
    required: bool = True
    transform: Optional[Sequence[str]] = None
    min_protocol_version: Optional[int] = None
    description: Optional[str] = None

    def __post_init__(self):
        """Compile transform pipeline for performance."""
        # Convert to immutable tuple if list provided
        if self.transform is not None and isinstance(self.transform, list):
            object.__setattr__(self, "transform", tuple(self.transform))

        # Compile transform pipeline (frozen-safe: use object.__setattr__)
        if self.transform:
            compiled = compile_transform_pipeline(self.transform)
            object.__setattr__(self, "_compiled_transform", compiled)
        else:
            object.__setattr__(self, "_compiled_transform", None)

    def parse(self, data: bytes) -> List[Any]:
        """Parse array values from data.

        Args:
            data: Normalized byte buffer

        Returns:
            List of parsed and transformed values

        Raises:
            IndexError: If any item exceeds data length
            ValueError: If parsing fails
        """
        values = []

        for i in range(self.count):
            item_offset = self.offset + (i * self.stride)

            # Parse raw value
            raw_value = self.item_type.parse(data, item_offset)

            # Apply transforms
            if self._compiled_transform:
                value = self._compiled_transform(raw_value)
            else:
                value = raw_value

            values.append(value)

        return values

    def size(self) -> int:
        """Total array size in bytes."""
        return self.count * self.stride


@dataclass(frozen=True)
class SubField:
    """Sub-field within a packed field.

    Represents a portion of bits extracted from a packed value.

    Example:
        SubField(
            name="voltage",
            bits="0:14",
            transform=["scale:0.001"],
            unit="V"
        )
    """

    name: str
    bits: str  # "start:end" (e.g., "0:14" for bits 0-13)
    transform: Optional[Sequence[str]] = None
    unit: Optional[str] = None
    enum: Optional[Mapping[int, str]] = None

    def __post_init__(self):
        """Parse bit range and compile transform."""
        # Convert to immutable tuple if list provided
        if self.transform is not None and isinstance(self.transform, list):
            object.__setattr__(self, "transform", tuple(self.transform))

        # Parse bits "start:end" (frozen-safe: use object.__setattr__)
        parts = self.bits.split(":")
        if len(parts) != 2:
            raise ValueError(f"Invalid bits spec: {self.bits} (expected 'start:end')")

        bit_start = int(parts[0])
        bit_end = int(parts[1])

        if bit_start >= bit_end:
            raise ValueError(f"Invalid bit range: {self.bits} (start >= end)")

        # Calculate mask and shift
        bit_count = bit_end - bit_start
        mask = (1 << bit_count) - 1
        shift = bit_start

        # Set computed attributes (frozen-safe)
        object.__setattr__(self, "bit_start", bit_start)
        object.__setattr__(self, "bit_end", bit_end)
        object.__setattr__(self, "mask", mask)
        object.__setattr__(self, "shift", shift)

        # Compile transform
        if self.transform:
            compiled = compile_transform_pipeline(self.transform)
            object.__setattr__(self, "_compiled_transform", compiled)
        else:
            object.__setattr__(self, "_compiled_transform", None)

    def extract(self, packed_value: int) -> Any:
        """Extract sub-field value from packed integer.

        Args:
            packed_value: Packed integer value

        Returns:
            Extracted and transformed value
        """
        # Extract bits
        raw_value = (packed_value >> self.shift) & self.mask

        # Apply enum mapping if present
        if self.enum:
            raw_value = self.enum.get(raw_value, f"UNKNOWN_{raw_value}")

        # Apply transforms
        if self._compiled_transform:
            return self._compiled_transform(raw_value)

        return raw_value


@dataclass(frozen=True)
class PackedField:
    """Packed field definition.

    Represents multiple sub-fields packed into a single integer value.
    Common for cell voltages with status bits.

    Example:
        PackedField(
            name="cells",
            offset=10,
            count=16,
            stride=2,
            fields=[
                SubField("voltage", bits="0:14", transform=["scale:0.001"], unit="V"),
                SubField("status", bits="14:16", enum={0: "OK", 1: "LOW", 2: "HIGH"})
            ]
        )
    """

    name: str
    offset: int
    count: int
    stride: int
    base_type: DataType
    fields: Sequence[SubField]
    required: bool = True
    min_protocol_version: Optional[int] = None
    description: Optional[str] = None

    def __post_init__(self):
        """Convert fields to immutable tuple."""
        # Convert to immutable tuple if list provided
        if self.fields is not None and isinstance(self.fields, list):
            object.__setattr__(self, "fields", tuple(self.fields))

    def parse(self, data: bytes) -> List[Dict[str, Any]]:
        """Parse packed field array.

        Args:
            data: Normalized byte buffer

        Returns:
            List of dicts, one per packed item, with sub-field names as keys

        Example output:
            [
                {"voltage": 3.245, "status": "OK"},
                {"voltage": 3.256, "status": "OK"},
                ...
            ]
        """
        items = []

        for i in range(self.count):
            item_offset = self.offset + (i * self.stride)

            # Parse packed value using configured base_type
            packed_value = self.base_type.parse(data, item_offset)

            # Extract all sub-fields
            item = {}
            for subfield in self.fields:
                item[subfield.name] = subfield.extract(packed_value)

            items.append(item)

        return items

    def size(self) -> int:
        """Total packed field size in bytes."""
        return self.count * self.stride


@dataclass(frozen=True)
class BlockSchema:
    """Schema definition for a V2 block.

    Defines the structure and validation rules for a specific block ID.

    Example:
        BlockSchema(
            block_id=100,
            name="APP_HOME_DATA",
            description="Main dashboard data",
            min_length=52,
            fields=[
                Field("soc", 0, UInt16(), unit="%"),
                Field("pack_voltage", 2, UInt16(), transform=["scale:0.1"], unit="V"),
                ArrayField("cell_voltages", 10, count=16, stride=2, item_type=UInt16())
            ],
            strict=True
        )
    """

    block_id: int
    name: str
    description: str
    min_length: int
    fields: Sequence[Any]  # Sequence[Field | ArrayField | PackedField]
    protocol_version: int = 2000
    schema_version: str = "1.0.0"
    strict: bool = True

    def __post_init__(self):
        """Convert fields to immutable tuple."""
        # Convert to immutable tuple if list provided
        if self.fields is not None and isinstance(self.fields, list):
            object.__setattr__(self, "fields", tuple(self.fields))

    def validate(self, data: bytes) -> ValidationResult:
        """Validate data against this schema.

        Args:
            data: Normalized byte buffer

        Returns:
            ValidationResult with errors, warnings, and missing fields
        """
        result = ValidationResult(valid=True)

        # Check minimum length
        if len(data) < self.min_length:
            result.valid = False
            result.errors.append(f"Data length {len(data)} < minimum {self.min_length}")

        # Check each field
        for field_def in self.fields:
            field_name = field_def.name

            try:
                # Check if field fits in data
                field_end = field_def.offset + field_def.size()

                if field_end > len(data):
                    if field_def.required:
                        result.valid = False
                        result.errors.append(
                            f"Required field '{field_name}' at offset {field_def.offset} "
                            f"exceeds data length {len(data)}"
                        )
                    else:
                        result.missing_fields.append(field_name)

            except Exception as e:
                if field_def.required:
                    result.valid = False
                    result.errors.append(f"Field '{field_name}' validation error: {e}")

        # Warn about extra data in strict mode
        if self.strict:
            max_offset = max((f.offset + f.size() for f in self.fields), default=0)

            if len(data) > max_offset:
                result.warnings.append(
                    f"Extra data beyond defined fields: {len(data) - max_offset} bytes"
                )

        return result

    def get_field(self, name: str) -> Optional[Any]:
        """Get field definition by name.

        Args:
            name: Field name

        Returns:
            Field definition or None if not found
        """
        for field_def in self.fields:
            if field_def.name == name:
                return field_def
        return None
=== КОНЕЦ ФАЙЛА: bluetti_sdk/protocol/v2/schema.py ===

=== НАЧАЛО ФАЙЛА: bluetti_sdk/protocol/v2/transforms.py ===
"""V2 Protocol Transform Pipeline

Transform operations for field values after type parsing.
Transforms are applied in sequence: raw_value → transform1 → transform2 → ... → final_value

Example:
    transform=["abs", "scale:0.1"]
    -52 → abs() → 52 → scale(0.1) → 5.2
"""

from __future__ import annotations

from dataclasses import dataclass
import math
from typing import Any, Callable, List, Sequence, Tuple, Union


class TransformError(Exception):
    """Error during transform execution."""


@dataclass(frozen=True)
class TransformStep:
    """Typed transform step."""

    name: str
    args: Tuple[str, ...] = ()

    def to_spec(self) -> str:
        if not self.args:
            return self.name
        return f"{self.name}:{':'.join(self.args)}"

    def __or__(self, other: "TransformInput") -> "TransformChain":
        return TransformChain((self,)).__or__(other)


@dataclass(frozen=True)
class TransformChain:
    """Composable chain of typed transform steps."""

    steps: Tuple[TransformStep, ...]

    def __or__(self, other: "TransformInput") -> "TransformChain":
        return TransformChain(self.steps + tuple(_normalize_transforms([other])))

    def to_specs(self) -> List[str]:
        return [step.to_spec() for step in self.steps]


TransformInput = Union[str, TransformStep, TransformChain]


def _transform_abs(value: Any) -> Any:
    """Absolute value transform."""
    return abs(value)


def _transform_scale(value: Any, factor: str) -> Any:
    """Scale (multiply) transform.

    Args:
        value: Input value
        factor: Scale factor as string (e.g., "0.1", "10", "0.001")

    Returns:
        value * factor
    """
    try:
        scale_factor = float(factor)
    except ValueError:
        raise TransformError(f"Invalid scale factor: {factor}")

    return value * scale_factor


def _transform_minus(value: Any, offset: str) -> Any:
    """Subtract constant transform.

    Common use: Temperature conversion (raw_byte - 40 = temp_C)

    Args:
        value: Input value
        offset: Constant to subtract (e.g., "40")

    Returns:
        value - offset
    """
    try:
        subtract_value = float(offset)
    except ValueError:
        raise TransformError(f"Invalid minus offset: {offset}")

    return value - subtract_value


def _transform_bitmask(value: Any, mask: str) -> Any:
    """Bitwise AND mask transform.

    Args:
        value: Input value
        mask: Hex mask (e.g., "0x3FFF", "0xC000")

    Returns:
        value & mask
    """
    try:
        # Support both "0x3FFF" and "3FFF"
        if mask.startswith("0x") or mask.startswith("0X"):
            mask_value = int(mask, 16)
        else:
            mask_value = int(mask, 16)
    except ValueError:
        raise TransformError(f"Invalid bitmask: {mask}")

    return int(value) & mask_value


def _transform_shift(value: Any, bits: str) -> Any:
    """Right bit shift transform.

    Args:
        value: Input value
        bits: Number of bits to shift right (e.g., "14")

    Returns:
        value >> bits
    """
    try:
        shift_bits = int(bits)
    except ValueError:
        raise TransformError(f"Invalid shift bits: {bits}")

    return int(value) >> shift_bits


def _transform_clamp(value: Any, min_val: str, max_val: str) -> Any:
    """Clamp value to range [min, max].

    Args:
        value: Input value
        min_val: Minimum value
        max_val: Maximum value

    Returns:
        Clamped value
    """
    try:
        min_v = float(min_val)
        max_v = float(max_val)
    except ValueError:
        raise TransformError(f"Invalid clamp range: [{min_val}, {max_val}]")

    return max(min_v, min(max_v, value))


# Transform registry
# Maps transform name to function
TRANSFORMS: dict[str, Callable[..., Any]] = {
    "abs": _transform_abs,
    "scale": _transform_scale,
    "minus": _transform_minus,
    "bitmask": _transform_bitmask,
    "shift": _transform_shift,
    "clamp": _transform_clamp,
}


def parse_transform_spec(spec: str) -> Tuple[str, List[str]]:
    """Parse transform specification string.

    Args:
        spec: Transform spec (e.g., "abs", "scale:0.1", "clamp:0:100")

    Returns:
        Tuple of (transform_name, [arg1, arg2, ...])

    Examples:
        "abs" → ("abs", [])
        "scale:0.1" → ("scale", ["0.1"])
        "clamp:0:100" → ("clamp", ["0", "100"])
    """
    if ":" not in spec:
        return (spec, [])

    parts = spec.split(":", 1)
    transform_name = parts[0]
    args_str = parts[1]

    # Split args by colon
    args = args_str.split(":")

    return (transform_name, args)


def apply_transform(spec: str, value: Any) -> Any:
    """Apply a single transform to a value.

    Args:
        spec: Transform specification (e.g., "abs", "scale:0.1")
        value: Input value

    Returns:
        Transformed value

    Raises:
        TransformError: If transform is unknown or execution fails
    """
    transform_name, args = parse_transform_spec(spec)

    if transform_name not in TRANSFORMS:
        raise TransformError(f"Unknown transform: {transform_name}")

    transform_func = TRANSFORMS[transform_name]

    try:
        return transform_func(value, *args)
    except TypeError as e:
        raise TransformError(f"Transform {transform_name} error: {e}")


def _normalize_transforms(specs: Sequence[TransformInput]) -> List[TransformStep]:
    normalized: List[TransformStep] = []
    for spec in specs:
        if isinstance(spec, TransformChain):
            normalized.extend(spec.steps)
        elif isinstance(spec, TransformStep):
            normalized.append(spec)
        else:
            transform_name, args = parse_transform_spec(spec)
            normalized.append(TransformStep(transform_name, tuple(args)))
    return normalized


def compile_transform_pipeline(
    specs: Sequence[TransformInput],
) -> Callable[[Any], Any]:
    """Compile a list of transform specs into a single function.

    This allows for performance optimization by pre-parsing transform specs.

    Args:
        specs: List of transform specifications (e.g., ["abs", "scale:0.1"])

    Returns:
        Function that applies all transforms in sequence

    Example:
        >>> pipeline = compile_transform_pipeline(["abs", "scale:0.1"])
        >>> pipeline(-52)
        5.2
    """
    # Pre-parse all transform specs
    compiled_transforms = []
    for step in _normalize_transforms(specs):
        transform_name, args = step.name, list(step.args)

        if transform_name not in TRANSFORMS:
            raise TransformError(f"Unknown transform: {transform_name}")

        transform_func = TRANSFORMS[transform_name]
        compiled_transforms.append((transform_func, args))

    # Return closure that applies all transforms
    def execute_pipeline(value: Any) -> Any:
        result = value
        for transform_func, args in compiled_transforms:
            result = transform_func(result, *args)
        return result

    return execute_pipeline


def apply_transform_pipeline(specs: Sequence[TransformInput], value: Any) -> Any:
    """Apply a sequence of transforms to a value.

    Args:
        specs: List of transform specifications (e.g., ["abs", "scale:0.1"])
        value: Input value

    Returns:
        Final transformed value

    Example:
        >>> apply_transform_pipeline(["abs", "scale:0.1"], -52)
        5.2
    """
    result = value
    for step in _normalize_transforms(specs):
        result = apply_transform(step.to_spec(), result)
    return result


def abs_() -> TransformStep:
    return TransformStep("abs")


def scale(factor: float) -> TransformStep:
    if factor == 0:
        raise ValueError("Scale factor cannot be zero")
    if not math.isfinite(factor):
        raise ValueError(f"Scale factor must be finite, got {factor}")
    return TransformStep("scale", (str(factor),))


def minus(offset: float) -> TransformStep:
    return TransformStep("minus", (str(offset),))


def bitmask(mask: int) -> TransformStep:
    return TransformStep("bitmask", (hex(mask),))


def shift(bits: int) -> TransformStep:
    return TransformStep("shift", (str(bits),))


def clamp(min_val: float, max_val: float) -> TransformStep:
    if min_val >= max_val:
        raise ValueError(f"min must be < max, got [{min_val}, {max_val}]")
    return TransformStep("clamp", (str(min_val), str(max_val)))
=== КОНЕЦ ФАЙЛА: bluetti_sdk/protocol/v2/transforms.py ===

=== НАЧАЛО ФАЙЛА: bluetti_sdk/protocol/v2/types.py ===
"""V2 protocol types."""

from dataclasses import dataclass
from typing import Any, Dict, Optional, Type, TypeVar

T = TypeVar("T")


@dataclass
class ParsedBlock:
    """Parsed block result.

    This is the CONTRACT between parser and device model.

    Parser outputs this, device model consumes it.
    """

    # Identity
    block_id: int
    name: str

    # Parsed data (flat dict)
    values: Dict[str, Any]

    # Metadata
    raw: bytes = b""
    length: int = 0
    protocol_version: int = 2000
    schema_version: str = "1.0.0"
    timestamp: float = 0.0

    # Validation result
    validation: Optional[Any] = None  # ValidationResult

    def to_dict(self) -> dict:
        """Export for JSON/MQTT.

        Returns:
            Flat dictionary of field values
        """
        return self.values.copy()

    def to_model(self, model_class: Type[T]) -> T:
        """Convert to dataclass.

        Args:
            model_class: Dataclass type to instantiate

        Returns:
            Instance of model_class with values from parsed data

        Example:
            >>> home_data = parsed.to_model(HomeData)
            >>> print(home_data.soc)
        """
        return model_class(**self.values)
=== КОНЕЦ ФАЙЛА: bluetti_sdk/protocol/v2/types.py ===

=== НАЧАЛО ФАЙЛА: bluetti_sdk/schemas/__init__.py ===
"""Schema Registry and Definitions

This module provides:
- SchemaRegistry: Central storage for BlockSchema instances
- Pre-defined schemas for common blocks (100, 1300, 6000, etc.)
- Declarative schema definition API (@block_schema decorator)
- Lazy registration to avoid import side-effects

Schemas are registered lazily via ensure_registered() to avoid
mutating global state on import. This improves testability and
makes behavior more predictable.

Declarative API Example:
    from bluetti_sdk.schemas import block_schema, block_field

    @block_schema(block_id=100, name="APP_HOME_DATA")
    @dataclass
    class AppHomeData:
        voltage: float = block_field(offset=0, type=UInt16(), unit="V")
        soc: int = block_field(offset=4, type=UInt16(), unit="%")
"""

# Import schema definitions (but don't register yet)
from .block_100 import BLOCK_100_SCHEMA
from .block_1300 import BLOCK_1300_SCHEMA
from .block_6000 import BLOCK_6000_SCHEMA
from .declarative import block_field, block_schema
from .registry import (
    SchemaRegistry,
    get,
    list_blocks,
    register,
    register_many,
    resolve_blocks,
)
from .registry import new_registry_with_builtins as _new_registry_with_builtins

# Track if schemas have been registered
_registered = False


def ensure_registered() -> None:
    """Ensure all schemas are registered (idempotent).

    This function can be called multiple times safely.
    Schemas are only registered once on first call.

    This lazy approach avoids import side-effects.
    """
    global _registered
    if _registered:
        return

    register_many(
        [
            BLOCK_100_SCHEMA,
            BLOCK_1300_SCHEMA,
            BLOCK_6000_SCHEMA,
        ]
    )
    _registered = True


def new_registry_with_builtins() -> SchemaRegistry:
    """Create a new client-scoped registry preloaded with built-in schemas."""
    ensure_registered()
    return _new_registry_with_builtins()


def _reset_registration_flag() -> None:
    """Reset registration flag (testing only).

    WARNING: For testing only. Use with _clear_for_testing() from registry.
    """
    global _registered
    _registered = False


__all__ = [
    "BLOCK_100_SCHEMA",
    "BLOCK_1300_SCHEMA",
    "BLOCK_6000_SCHEMA",
    "block_field",
    "block_schema",
    "ensure_registered",
    "get",
    "list_blocks",
    "new_registry_with_builtins",
    "register",
    "register_many",
    "resolve_blocks",
]
=== КОНЕЦ ФАЙЛА: bluetti_sdk/schemas/__init__.py ===

=== НАЧАЛО ФАЙЛА: bluetti_sdk/schemas/block_100.py ===
"""Block 100 - APP_HOME_DATA Schema

Main dashboard data for Elite V2 devices.
Primary data source for monitoring power flows, SOC, and energy totals.
"""

from ..protocol.v2.datatypes import Int32, String, UInt16, UInt32
from ..protocol.v2.schema import BlockSchema, Field

BLOCK_100_SCHEMA = BlockSchema(
    block_id=100,
    name="APP_HOME_DATA",
    description="Main dashboard data (SOC, power flows, energy totals)",
    min_length=120,  # Core fields, extended fields optional
    protocol_version=2000,
    schema_version="1.0.0",
    strict=False,  # Allow partial data for older firmware
    fields=[
        # === Battery Status (0-19) ===
        Field(
            name="pack_voltage",
            offset=0,
            type=UInt16(),
            transform=["scale:0.1"],
            unit="V",
            required=True,
            description="Total pack voltage",
        ),
        Field(
            name="pack_current",
            offset=2,
            type=UInt16(),
            transform=["scale:0.1"],
            unit="A",
            required=True,
            description="Total pack current",
        ),
        Field(
            name="soc",
            offset=4,
            type=UInt16(),
            unit="%",
            required=True,
            description="State of charge (battery %)",
        ),
        Field(
            name="pack_online",
            offset=16,
            type=UInt16(),
            description="Pack online status bitmap",
        ),
        # === Device Info (20-47) ===
        Field(
            name="device_model",
            offset=20,
            type=String(length=12),
            description="Device model string",
        ),
        Field(
            name="device_serial",
            offset=32,
            type=String(length=8),
            description="Device serial number",
        ),
        # === Temperatures (48-53) ===
        Field(
            name="pack_temp_avg",
            offset=48,
            type=UInt16(),
            transform=["minus:40"],
            unit="°C",
            description="Average pack temperature",
        ),
        Field(
            name="pack_temp_max",
            offset=50,
            type=UInt16(),
            transform=["minus:40"],
            unit="°C",
            description="Maximum pack temperature",
        ),
        Field(
            name="pack_temp_min",
            offset=52,
            type=UInt16(),
            transform=["minus:40"],
            unit="°C",
            description="Minimum pack temperature",
        ),
        # === Power Flows (80-95) ===
        # Requires protocol >= 2001
        Field(
            name="dc_input_power",
            offset=80,
            type=UInt32(),
            unit="W",
            min_protocol_version=2001,
            description="Total DC input power",
        ),
        Field(
            name="ac_input_power",
            offset=84,
            type=UInt32(),
            unit="W",
            min_protocol_version=2001,
            description="Total AC input power",
        ),
        Field(
            name="pv_power",
            offset=88,
            type=UInt32(),
            unit="W",
            min_protocol_version=2001,
            description="Total PV (solar) power",
        ),
        Field(
            name="grid_power",
            offset=92,
            type=Int32(),  # SIGNED! Negative = export
            unit="W",
            min_protocol_version=2001,
            description="Grid power (negative = export to grid)",
        ),
        # === Energy Totals (100-119) ===
        Field(
            name="total_energy_charge",
            offset=100,
            type=UInt32(),
            transform=["scale:0.1"],
            unit="kWh",
            min_protocol_version=2001,
            description="Total DC energy charged",
        ),
        Field(
            name="ac_output_power",
            offset=104,
            type=UInt32(),
            unit="W",
            min_protocol_version=2001,
            description="Total AC output power",
        ),
        Field(
            name="pv_charge_energy",
            offset=108,
            type=UInt32(),
            transform=["scale:0.1"],
            unit="kWh",
            min_protocol_version=2001,
            description="Total PV charging energy",
        ),
        Field(
            name="total_energy_discharge",
            offset=112,
            type=UInt32(),
            transform=["scale:0.1"],
            unit="kWh",
            min_protocol_version=2001,
            description="Total discharge energy",
        ),
        Field(
            name="total_feedback_energy",
            offset=116,
            type=UInt32(),
            transform=["scale:0.1"],
            unit="kWh",
            min_protocol_version=2001,
            description="Total grid feedback (export) energy",
        ),
        # === State of Health (120+) ===
        Field(
            name="soh",
            offset=120,
            type=UInt16(),
            unit="%",
            description="State of health (battery degradation)",
        ),
        # === PV Details (124-135) ===
        Field(
            name="pv1_voltage",
            offset=124,
            type=UInt16(),
            transform=["scale:0.1"],
            unit="V",
            description="PV1 voltage",
        ),
        Field(
            name="pv1_current",
            offset=126,
            type=UInt16(),
            transform=["scale:0.1"],
            unit="A",
            description="PV1 current",
        ),
        Field(
            name="pv2_voltage",
            offset=128,
            type=UInt16(),
            transform=["scale:0.1"],
            unit="V",
            description="PV2 voltage",
        ),
        Field(
            name="pv2_current",
            offset=130,
            type=UInt16(),
            transform=["scale:0.1"],
            unit="A",
            description="PV2 current",
        ),
        # === Power (calculated, derived from voltage * current) ===
        Field(
            name="pack_power",
            offset=6,
            type=UInt32(),
            unit="W",
            description="Pack power (calculated in device model)",
        ),
        Field(
            name="load_power",
            offset=10,
            type=UInt32(),
            unit="W",
            description="Load power (calculated in device model)",
        ),
    ],
)
=== КОНЕЦ ФАЙЛА: bluetti_sdk/schemas/block_100.py ===

=== НАЧАЛО ФАЙЛА: bluetti_sdk/schemas/block_100_declarative.py ===
"""Block 100 - APP_HOME_DATA Declarative Schema

Declarative version of Block 100 using the declarative schema API.
This demonstrates type-safe block definitions with IDE autocomplete support.

Usage:
    # Get generated BlockSchema
    schema = AppHomeDataBlock.to_schema()

    # Register with parser
    parser.register_schema(schema)

    # Parse block
    parsed = parser.parse_block(100, data)

    # Type-safe access (IDE autocomplete works!)
    voltage = parsed.values['pack_voltage']
"""

from dataclasses import dataclass

from ..protocol.v2.datatypes import Int32, String, UInt16, UInt32
from .declarative import block_field, block_schema


@block_schema(
    block_id=100,
    name="APP_HOME_DATA",
    description="Main dashboard data (SOC, power flows, energy totals)",
    min_length=120,  # Core fields, extended fields optional
    protocol_version=2000,
    schema_version="1.0.0",
    strict=False,  # Allow partial data for older firmware
)
@dataclass
class AppHomeDataBlock:
    """Main dashboard data for Elite V2 devices.

    Primary data source for monitoring power flows, SOC, and energy totals.
    """

    # === Battery Status (0-19) ===
    pack_voltage: float = block_field(
        offset=0,
        type=UInt16(),
        transform=["scale:0.1"],
        unit="V",
        required=True,
        description="Total pack voltage",
        default=0.0,
    )

    pack_current: float = block_field(
        offset=2,
        type=UInt16(),
        transform=["scale:0.1"],
        unit="A",
        required=True,
        description="Total pack current",
        default=0.0,
    )

    soc: int = block_field(
        offset=4,
        type=UInt16(),
        unit="%",
        required=True,
        description="State of charge (battery %)",
        default=0,
    )

    pack_power: int = block_field(
        offset=6,
        type=UInt32(),
        unit="W",
        description="Pack power (calculated in device model)",
        default=0,
    )

    load_power: int = block_field(
        offset=10,
        type=UInt32(),
        unit="W",
        description="Load power (calculated in device model)",
        default=0,
    )

    pack_online: int = block_field(
        offset=16, type=UInt16(), description="Pack online status bitmap", default=0
    )

    # === Device Info (20-47) ===
    device_model: str = block_field(
        offset=20, type=String(length=12), description="Device model string", default=""
    )

    device_serial: str = block_field(
        offset=32, type=String(length=8), description="Device serial number", default=""
    )

    # === Temperatures (48-53) ===
    pack_temp_avg: int = block_field(
        offset=48,
        type=UInt16(),
        transform=["minus:40"],
        unit="°C",
        description="Average pack temperature",
        default=0,
    )

    pack_temp_max: int = block_field(
        offset=50,
        type=UInt16(),
        transform=["minus:40"],
        unit="°C",
        description="Maximum pack temperature",
        default=0,
    )

    pack_temp_min: int = block_field(
        offset=52,
        type=UInt16(),
        transform=["minus:40"],
        unit="°C",
        description="Minimum pack temperature",
        default=0,
    )

    # === Power Flows (80-95) ===
    # Requires protocol >= 2001
    dc_input_power: int = block_field(
        offset=80,
        type=UInt32(),
        unit="W",
        min_protocol_version=2001,
        description="Total DC input power",
        default=0,
    )

    ac_input_power: int = block_field(
        offset=84,
        type=UInt32(),
        unit="W",
        min_protocol_version=2001,
        description="Total AC input power",
        default=0,
    )

    pv_power: int = block_field(
        offset=88,
        type=UInt32(),
        unit="W",
        min_protocol_version=2001,
        description="Total PV (solar) power",
        default=0,
    )

    grid_power: int = block_field(
        offset=92,
        type=Int32(),  # SIGNED! Negative = export
        unit="W",
        min_protocol_version=2001,
        description="Grid power (negative = export to grid)",
        default=0,
    )

    # === Energy Totals (100-119) ===
    total_energy_charge: float = block_field(
        offset=100,
        type=UInt32(),
        transform=["scale:0.1"],
        unit="kWh",
        min_protocol_version=2001,
        description="Total DC energy charged",
        default=0.0,
    )

    ac_output_power: int = block_field(
        offset=104,
        type=UInt32(),
        unit="W",
        min_protocol_version=2001,
        description="Total AC output power",
        default=0,
    )

    pv_charge_energy: float = block_field(
        offset=108,
        type=UInt32(),
        transform=["scale:0.1"],
        unit="kWh",
        min_protocol_version=2001,
        description="Total PV charging energy",
        default=0.0,
    )

    total_energy_discharge: float = block_field(
        offset=112,
        type=UInt32(),
        transform=["scale:0.1"],
        unit="kWh",
        min_protocol_version=2001,
        description="Total discharge energy",
        default=0.0,
    )

    total_feedback_energy: float = block_field(
        offset=116,
        type=UInt32(),
        transform=["scale:0.1"],
        unit="kWh",
        min_protocol_version=2001,
        description="Total grid feedback (export) energy",
        default=0.0,
    )

    # === State of Health (120+) ===
    soh: int = block_field(
        offset=120,
        type=UInt16(),
        unit="%",
        description="State of health (battery degradation)",
        default=100,
    )

    # === PV Details (124-135) ===
    pv1_voltage: float = block_field(
        offset=124,
        type=UInt16(),
        transform=["scale:0.1"],
        unit="V",
        description="PV1 voltage",
        default=0.0,
    )

    pv1_current: float = block_field(
        offset=126,
        type=UInt16(),
        transform=["scale:0.1"],
        unit="A",
        description="PV1 current",
        default=0.0,
    )

    pv2_voltage: float = block_field(
        offset=128,
        type=UInt16(),
        transform=["scale:0.1"],
        unit="V",
        description="PV2 voltage",
        default=0.0,
    )

    pv2_current: float = block_field(
        offset=130,
        type=UInt16(),
        transform=["scale:0.1"],
        unit="A",
        description="PV2 current",
        default=0.0,
    )


# Generate BlockSchema for compatibility with existing code
BLOCK_100_DECLARATIVE_SCHEMA = AppHomeDataBlock.to_schema()  # type: ignore[attr-defined]
=== КОНЕЦ ФАЙЛА: bluetti_sdk/schemas/block_100_declarative.py ===

=== НАЧАЛО ФАЙЛА: bluetti_sdk/schemas/block_1300.py ===
"""Block 1300 - INV_GRID_INFO Schema

Grid input monitoring data.
Tracks grid voltage, frequency, current, and power.
"""

from ..protocol.v2.datatypes import Int16, UInt16, UInt32
from ..protocol.v2.schema import BlockSchema, Field

BLOCK_1300_SCHEMA = BlockSchema(
    block_id=1300,
    name="INV_GRID_INFO",
    description="Grid input monitoring (voltage, frequency, power)",
    min_length=32,
    protocol_version=2000,
    schema_version="1.0.0",
    strict=True,
    fields=[
        # === Grid AC Parameters ===
        Field(
            name="frequency",
            offset=0,
            type=UInt16(),
            transform=["scale:0.1"],
            unit="Hz",
            required=True,
            description="Grid frequency (typically 50Hz or 60Hz)",
        ),
        # === Phase 0 (Main Phase) ===
        Field(
            name="phase_0_power",
            offset=26,
            type=Int16(),
            transform=["abs"],
            unit="W",
            required=True,
            description="Phase 0 power (absolute value)",
        ),
        Field(
            name="phase_0_voltage",
            offset=28,
            type=UInt16(),
            transform=["scale:0.1"],
            unit="V",
            required=True,
            description="Phase 0 voltage",
        ),
        Field(
            name="phase_0_current",
            offset=30,
            type=Int16(),
            transform=["abs", "scale:0.1"],
            unit="A",
            required=True,
            description="Phase 0 current (absolute value)",
        ),
        # === Optional: Three-Phase Support ===
        # Note: Most residential devices are single-phase
        # These fields may be zero or unavailable
        Field(
            name="phase_1_voltage",
            offset=2,
            type=UInt16(),
            transform=["scale:0.1"],
            unit="V",
            required=False,
            description="Phase 1 voltage (3-phase systems)",
        ),
        Field(
            name="phase_2_voltage",
            offset=4,
            type=UInt16(),
            transform=["scale:0.1"],
            unit="V",
            required=False,
            description="Phase 2 voltage (3-phase systems)",
        ),
        # === Energy Counters ===
        # Note: Offsets need to be verified from actual data
        # These are extended fields that may not always be present
        Field(
            name="total_charge_energy",
            offset=6,
            type=UInt32(),
            transform=["scale:0.1"],
            unit="kWh",
            required=False,
            description="Total energy charged from grid",
        ),
        Field(
            name="total_feedback_energy",
            offset=10,
            type=UInt32(),
            transform=["scale:0.1"],
            unit="kWh",
            required=False,
            description="Total energy fed back to grid",
        ),
    ],
)
=== КОНЕЦ ФАЙЛА: bluetti_sdk/schemas/block_1300.py ===

=== НАЧАЛО ФАЙЛА: bluetti_sdk/schemas/block_6000.py ===
"""Block 6000 - PACK_MAIN_INFO Schema

Battery pack main information and status.
Detailed battery health, temperature, and protection status.
"""

from ..protocol.v2.datatypes import UInt8, UInt16
from ..protocol.v2.schema import BlockSchema, Field

BLOCK_6000_SCHEMA = BlockSchema(
    block_id=6000,
    name="PACK_MAIN_INFO",
    description="Battery pack detailed status and health",
    min_length=64,
    protocol_version=2000,
    schema_version="1.0.0",
    strict=False,  # Allow partial data
    fields=[
        # === Pack Configuration ===
        Field(
            name="pack_volt_type",
            offset=0,
            type=UInt16(),
            description="Pack voltage type",
        ),
        Field(
            name="pack_count",
            offset=3,
            type=UInt8(),
            description="Number of battery packs",
        ),
        Field(
            name="pack_online",
            offset=4,
            type=UInt16(),
            description="Pack online status bitmap",
        ),
        # === Battery Status ===
        Field(
            name="voltage",
            offset=6,
            type=UInt16(),
            transform=["scale:0.1"],
            unit="V",
            required=True,
            description="Total pack voltage",
        ),
        Field(
            name="current",
            offset=8,
            type=UInt16(),
            transform=["scale:0.1"],
            unit="A",
            required=True,
            description="Total pack current",
        ),
        Field(
            name="soc",
            offset=11,
            type=UInt8(),
            unit="%",
            required=True,
            description="State of charge",
        ),
        Field(
            name="soh",
            offset=13,
            type=UInt8(),
            unit="%",
            required=True,
            description="State of health",
        ),
        # === Temperature ===
        Field(
            name="temp_avg",
            offset=14,
            type=UInt16(),
            transform=["minus:40"],
            unit="°C",
            description="Average temperature",
        ),
        # Note: temp_max and temp_min may be at different offsets
        # Need to verify from actual data
        # === Operating Status ===
        Field(
            name="running_status",
            offset=17,
            type=UInt8(),
            description="Running status code",
        ),
        Field(
            name="charging_status",
            offset=19,
            type=UInt8(),
            description="Charging status code",
        ),
        # === Charge/Discharge Limits ===
        Field(
            name="max_charge_voltage",
            offset=20,
            type=UInt16(),
            transform=["scale:0.1"],
            unit="V",
            description="Maximum charge voltage",
        ),
        Field(
            name="max_charge_current",
            offset=22,
            type=UInt16(),
            transform=["scale:0.1"],
            unit="A",
            description="Maximum charge current",
        ),
        Field(
            name="max_discharge_current",
            offset=24,
            type=UInt16(),
            transform=["scale:0.1"],
            unit="A",
            description="Maximum discharge current",
        ),
        # === MOS Status ===
        Field(
            name="pack_mos",
            offset=32,
            type=UInt16(),
            description="Pack MOS status bitmap",
        ),
        # === Time Estimates ===
        Field(
            name="time_to_full",
            offset=34,
            type=UInt16(),
            unit="min",
            description="Estimated time to full charge",
        ),
        Field(
            name="time_to_empty",
            offset=36,
            type=UInt16(),
            unit="min",
            description="Estimated time to empty",
        ),
        # === Protection & Faults ===
        # Note: Protection status at offset 58-61 is complex (4-byte bitmap)
        # Pack fault bits at offset 62-63 (if size >= 64)
        Field(
            name="pack_fault_bits",
            offset=62,
            type=UInt16(),
            description="Pack fault status bitmap",
        ),
        # === Computed Fields ===
        Field(
            name="power",
            offset=10,  # Placeholder, computed as voltage * current
            type=UInt16(),
            unit="W",
            description="Pack power (computed)",
        ),
        Field(
            name="cell_count",
            offset=38,
            type=UInt16(),
            description="Number of cells in pack",
        ),
        Field(
            name="cycles",
            offset=40,
            type=UInt16(),
            description="Charge/discharge cycle count",
        ),
        # === Status Flags (derived from bitmaps) ===
        Field(
            name="charging",
            offset=19,  # Derived from charging_status
            type=UInt8(),
            description="Is charging (boolean flag)",
        ),
        Field(
            name="discharging",
            offset=17,  # Derived from running_status
            type=UInt8(),
            description="Is discharging (boolean flag)",
        ),
        # === Temperature Min/Max ===
        Field(
            name="temp_max",
            offset=50,
            type=UInt16(),
            transform=["minus:40"],
            unit="°C",
            description="Maximum cell temperature",
        ),
        Field(
            name="temp_min",
            offset=52,
            type=UInt16(),
            transform=["minus:40"],
            unit="°C",
            description="Minimum cell temperature",
        ),
    ],
)
=== КОНЕЦ ФАЙЛА: bluetti_sdk/schemas/block_6000.py ===

=== НАЧАЛО ФАЙЛА: bluetti_sdk/schemas/declarative.py ===
"""Declarative Block Schema Definition

Provides decorator-based declarative API for defining block schemas.
Automatically generates BlockSchema from class definitions.

Example:
    @block_schema(block_id=100, name="APP_HOME_DATA")
    class AppHomeDataBlock:
        '''Main dashboard data.'''

        pack_voltage: float = block_field(
            offset=0,
            type=UInt16(),
            transform=["scale:0.1"],
            unit="V",
            description="Total pack voltage"
        )

        soc: int = block_field(
            offset=4,
            type=UInt16(),
            unit="%",
            description="State of charge"
        )

Usage:
    # Auto-generate BlockSchema
    schema = AppHomeDataBlock.to_schema()

    # Type-safe access to parsed data
    data = parser.parse_block(100, raw_bytes)
    voltage = data.values['pack_voltage']  # IDE autocomplete works!
"""

from dataclasses import dataclass, fields, is_dataclass
from dataclasses import field as dataclass_field
from typing import Any, Callable, List, Optional, Sequence, Type, TypeVar

from ..protocol.v2.datatypes import DataType
from ..protocol.v2.schema import BlockSchema, Field

T = TypeVar("T")


@dataclass(frozen=True)
class BlockFieldMetadata:
    """Metadata for a declarative block field.

    This is stored in dataclass field metadata and used to generate
    BlockSchema Field definitions.
    """

    offset: int
    type: DataType
    unit: Optional[str] = None
    required: bool = True
    transform: Optional[Sequence[str]] = None
    min_protocol_version: Optional[int] = None
    description: Optional[str] = None


def block_field(
    offset: int,
    type: DataType,
    unit: Optional[str] = None,
    required: bool = True,
    transform: Optional[List[str]] = None,
    min_protocol_version: Optional[int] = None,
    description: Optional[str] = None,
    default: Any = None,
) -> Any:
    """Define a block field with metadata.

    Args:
        offset: Byte offset in block
        type: DataType for parsing
        unit: Physical unit (e.g., "V", "A", "%")
        required: Whether field is required
        transform: Transform pipeline (e.g., ["scale:0.1"])
        min_protocol_version: Minimum protocol version
        description: Field description
        default: Default value if field missing

    Returns:
        dataclass field with BlockFieldMetadata
    """
    metadata = BlockFieldMetadata(
        offset=offset,
        type=type,
        unit=unit,
        required=required,
        transform=tuple(transform) if transform else None,
        min_protocol_version=min_protocol_version,
        description=description,
    )

    return dataclass_field(default=default, metadata={"block_field": metadata})


def block_schema(
    block_id: int,
    name: str,
    description: Optional[str] = None,
    min_length: Optional[int] = None,
    protocol_version: int = 2000,
    schema_version: str = "1.0.0",
    strict: bool = True,
) -> Callable[[Type[T]], Type[T]]:
    """Decorator to mark a class as a declarative block schema.

    Automatically generates BlockSchema from class fields.

    Args:
        block_id: Unique block identifier
        name: Block name (e.g., "APP_HOME_DATA")
        description: Block description
        min_length: Minimum data length in bytes (auto-calculated if None)
        protocol_version: Protocol version
        schema_version: Schema version
        strict: Strict validation mode

    Returns:
        Decorator function

    Example:
        @block_schema(block_id=100, name="APP_HOME_DATA")
        class AppHomeData:
            voltage: float = block_field(offset=0, type=UInt16())
    """

    def decorator(cls: Type[T]) -> Type[T]:
        # Generate BlockSchema from class fields
        schema = _generate_schema(
            cls,
            block_id=block_id,
            name=name,
            description=description or cls.__doc__ or "",
            min_length=min_length,
            protocol_version=protocol_version,
            schema_version=schema_version,
            strict=strict,
        )

        # Attach schema to class
        cls._block_schema = schema  # type: ignore
        cls.to_schema = classmethod(lambda _: schema)  # type: ignore

        return cls

    return decorator


def _generate_schema(
    cls: Type[Any],
    block_id: int,
    name: str,
    description: str,
    min_length: Optional[int],
    protocol_version: int,
    schema_version: str,
    strict: bool,
) -> BlockSchema:
    """Generate BlockSchema from declarative class.

    Args:
        cls: Dataclass with block_field definitions
        block_id: Block ID
        name: Block name
        description: Block description
        min_length: Minimum data length
        protocol_version: Protocol version
        schema_version: Schema version
        strict: Strict mode

    Returns:
        Generated BlockSchema

    Raises:
        TypeError: If cls is not a dataclass
    """
    # Validate that cls is a dataclass
    if not is_dataclass(cls):
        raise TypeError(
            f"@block_schema can only be applied to dataclasses. "
            f"Add @dataclass decorator to {cls.__name__}. "
            f"Example:\n"
            f"  @block_schema(block_id={block_id}, name='{name}')\n"
            f"  @dataclass\n"
            f"  class {cls.__name__}:\n"
            f"      ..."
        )

    # Extract field definitions from dataclass
    schema_fields: List[Field] = []
    max_offset = 0

    for field_def in fields(cls):
        # Get block field metadata
        metadata = field_def.metadata.get("block_field")
        if not metadata:
            # Skip non-block fields
            continue

        # Create Field from metadata
        schema_field = Field(
            name=field_def.name,
            offset=metadata.offset,
            type=metadata.type,
            unit=metadata.unit,
            required=metadata.required,
            transform=metadata.transform,
            min_protocol_version=metadata.min_protocol_version,
            description=metadata.description,
        )

        schema_fields.append(schema_field)

        # Track max offset for auto min_length
        field_end = metadata.offset + metadata.type.size()
        max_offset = max(max_offset, field_end)

    # Auto-calculate min_length if not provided
    if min_length is None:
        min_length = max_offset

    # Generate BlockSchema
    return BlockSchema(
        block_id=block_id,
        name=name,
        description=description.strip(),
        min_length=min_length,
        protocol_version=protocol_version,
        schema_version=schema_version,
        strict=strict,
        fields=schema_fields,
    )
=== КОНЕЦ ФАЙЛА: bluetti_sdk/schemas/declarative.py ===

=== НАЧАЛО ФАЙЛА: bluetti_sdk/schemas/registry.py ===
"""Schema Registry - Central schema storage and resolution.

Responsibilities:
- Store BlockSchema instances by block_id
- Resolve schemas for device profiles
- Provide fail-fast or lenient lookup
- Validate schema consistency (prevent conflicting registrations)

This is a MODULE-LEVEL registry (singleton pattern).

Registration Strategy:
- Schemas are registered LAZILY via ensure_registered() from schemas/__init__.py
- This avoids import side-effects and improves testability
- Registration is idempotent (safe to call multiple times)
- V2Client automatically calls ensure_registered() during initialization
"""

import logging
from typing import Dict, List, Optional

# Forward declare for type hints
from ..protocol.v2.schema import BlockSchema

logger = logging.getLogger(__name__)


class SchemaRegistry:
    """Schema registry implementation.

    Supports instance-scoped schema catalogs for runtime use.
    """

    def __init__(self) -> None:
        self._schemas: Dict[int, BlockSchema] = {}

    def register(self, schema: BlockSchema) -> None:
        """Register a schema.

        Args:
            schema: BlockSchema to register

        Raises:
            ValueError: If block_id already registered with different schema
        """
        if schema.block_id in self._schemas:
            existing = self._schemas[schema.block_id]

            # Check if it's truly the same schema (not just same name)
            if existing.name != schema.name:
                raise ValueError(
                    f"Block {schema.block_id} already registered as "
                    f"'{existing.name}', cannot re-register as '{schema.name}'"
                )

            # Full structure validation: check field fingerprints
            # Compare: name, offset, type, required, transform
            conflicts = self._check_field_conflicts(existing, schema)
            if conflicts:
                raise ValueError(
                    f"Block {schema.block_id} ({schema.name}) structure conflict:\n"
                    + "\n".join(conflicts)
                )

            # Same block_id, same name, same structure → safe to skip
            logger.debug(f"Block {schema.block_id} already registered, skipping")
            return

        self._schemas[schema.block_id] = schema
        logger.debug(f"Registered schema: Block {schema.block_id} ({schema.name})")

    def _check_field_conflicts(
        self, existing: BlockSchema, new: BlockSchema
    ) -> List[str]:
        """Check for field-level conflicts between schemas.

        Compares field names, offsets, types, required flags, and transforms.

        Args:
            existing: Currently registered schema
            new: New schema to register

        Returns:
            List of conflict descriptions (empty if no conflicts)
        """
        conflicts = []

        # Build field maps
        existing_fields = {f.name: f for f in existing.fields}
        new_fields = {f.name: f for f in new.fields}

        # Check for added/removed fields
        existing_names = set(existing_fields.keys())
        new_names = set(new_fields.keys())

        if existing_names != new_names:
            added = new_names - existing_names
            removed = existing_names - new_names
            if added:
                conflicts.append(f"  Added fields: {sorted(added)}")
            if removed:
                conflicts.append(f"  Removed fields: {sorted(removed)}")

        # Check common fields for structural changes
        for name in existing_names & new_names:
            existing_field = existing_fields[name]
            new_field = new_fields[name]

            # Compare offset
            if existing_field.offset != new_field.offset:
                conflicts.append(
                    f"  Field '{name}': offset changed from "
                    f"{existing_field.offset} to {new_field.offset}"
                )

            # Compare type (class name + parameters)
            existing_type_repr = self._get_type_fingerprint(existing_field.type)
            new_type_repr = self._get_type_fingerprint(new_field.type)

            if existing_type_repr != new_type_repr:
                conflicts.append(
                    f"  Field '{name}': type changed from "
                    f"{existing_type_repr} to {new_type_repr}"
                )

            # Compare required flag
            if existing_field.required != new_field.required:
                conflicts.append(
                    f"  Field '{name}': required changed from "
                    f"{existing_field.required} to {new_field.required}"
                )

            # Compare transform
            if existing_field.transform != new_field.transform:
                conflicts.append(
                    f"  Field '{name}': transform changed from "
                    f"{existing_field.transform} to {new_field.transform}"
                )

        return conflicts

    def _get_type_fingerprint(self, field_type: object) -> str:
        """Get a unique fingerprint for a field type.

        Includes both the type class name and its parameters (length, bits, etc).

        Args:
            field_type: DataType instance

        Returns:
            String representation like "String(length=8)" or "Bitmap(bits=16)"
        """
        type_name = type(field_type).__name__

        # Extract relevant parameters based on type
        params = []

        # String types have length attribute
        if hasattr(field_type, "length"):
            params.append(f"length={field_type.length}")

        # Bitmap types have bits attribute
        if hasattr(field_type, "bits"):
            params.append(f"bits={field_type.bits}")

        # Enum types have mapping attribute
        if hasattr(field_type, "mapping") and field_type.mapping is not None:
            # For enums, include full mapping as fingerprint (sorted for stability)
            # Convert to sorted tuple of (value, name) pairs
            mapping_items = sorted(field_type.mapping.items())
            mapping_repr = repr(tuple(mapping_items))
            params.append(f"mapping={mapping_repr}")

        # Build fingerprint
        if params:
            return f"{type_name}({', '.join(params)})"
        else:
            return type_name

    def register_many(self, schemas: List[BlockSchema]) -> None:
        """Register multiple schemas at once.

        Args:
            schemas: List of BlockSchema to register
        """
        for schema in schemas:
            self.register(schema)

    def get(self, block_id: int) -> Optional[BlockSchema]:
        """Get schema by block_id.

        Args:
            block_id: Block ID to look up

        Returns:
            BlockSchema or None if not found
        """
        return self._schemas.get(block_id)

    def list_blocks(self) -> List[int]:
        """List all registered block IDs.

        Returns:
            Sorted list of registered block IDs
        """
        return sorted(self._schemas.keys())

    def resolve_blocks(
        self, block_ids: List[int], strict: bool = True
    ) -> Dict[int, BlockSchema]:
        """Resolve schemas for a list of block IDs.

        Args:
            block_ids: List of block IDs to resolve
            strict: If True, raise error for missing schemas.
                   If False, skip missing schemas and log warning.

        Returns:
            Dict mapping block_id → BlockSchema (only found schemas)

        Raises:
            ValueError: If strict=True and any schema is missing
        """
        resolved = {}
        missing = []

        for block_id in block_ids:
            schema = self.get(block_id)
            if schema:
                resolved[block_id] = schema
            else:
                missing.append(block_id)

        if missing:
            msg = f"Missing schemas for blocks: {missing}"
            if strict:
                raise ValueError(f"{msg}. Available blocks: {self.list_blocks()}")
            else:
                logger.warning(msg)

        return resolved

    def clear(self) -> None:
        """Clear all registered schemas.

        WARNING: This is intended for testing only.
        """
        self._schemas.clear()


# Module-level singleton instance used only as default built-in catalog.
_registry = SchemaRegistry()

# Public API (module-level functions that delegate to singleton)


def register(schema: BlockSchema) -> None:
    """Register a schema in the global registry."""
    _registry.register(schema)


def register_many(schemas: List[BlockSchema]) -> None:
    """Register multiple schemas in the global registry."""
    _registry.register_many(schemas)


def get(block_id: int) -> Optional[BlockSchema]:
    """Get schema from global registry."""
    return _registry.get(block_id)


def list_blocks() -> List[int]:
    """List all registered block IDs."""
    return _registry.list_blocks()


def resolve_blocks(block_ids: List[int], strict: bool = True) -> Dict[int, BlockSchema]:
    """Resolve schemas for block IDs from global registry."""
    return _registry.resolve_blocks(block_ids, strict)


def _clear_for_testing() -> None:
    """Clear global registry.

    WARNING: This is for testing only. Do not use in production code.
    Clearing the registry at runtime will break all schema resolution.
    """
    _registry.clear()


def new_registry_with_builtins() -> SchemaRegistry:
    """Create a new registry instance preloaded with built-in schemas."""
    registry = SchemaRegistry()
    for block_id in list_blocks():
        schema = get(block_id)
        if schema is not None:
            registry.register(schema)
    return registry
=== КОНЕЦ ФАЙЛА: bluetti_sdk/schemas/registry.py ===

=== НАЧАЛО ФАЙЛА: bluetti_sdk/transport/__init__.py ===
"""Transport layer - MQTT and future transport implementations.

This module provides transport layer implementations for communicating
with Bluetti devices.

Available transports:
    - MQTTTransport: MQTT-based transport for V2 devices
"""

from .base import TransportProtocol
from .mqtt import MQTTConfig, MQTTTransport

__all__ = [
    "MQTTConfig",
    "MQTTTransport",
    "TransportProtocol",
]
=== КОНЕЦ ФАЙЛА: bluetti_sdk/transport/__init__.py ===

=== НАЧАЛО ФАЙЛА: bluetti_sdk/transport/base.py ===
"""Transport layer base protocol.

DEPRECATED: This module is deprecated. Import from bluetti_sdk.contracts instead.
Kept for backward compatibility.
"""

# Re-export from contracts for backward compatibility
from ..contracts.transport import TransportProtocol

__all__ = ["TransportProtocol"]
=== КОНЕЦ ФАЙЛА: bluetti_sdk/transport/base.py ===

=== НАЧАЛО ФАЙЛА: bluetti_sdk/transport/mqtt.py ===
"""MQTT Transport Layer

Minimal MQTT transport for V2 devices.
Implements TransportProtocol interface.

Responsibilities:
- Connect to Bluetti MQTT broker
- Send Modbus frames
- Receive responses
- Timeout handling

Does NOT know about:
- Block schemas
- Field parsing
- Device models
"""

import logging
import os
import ssl
import tempfile
from dataclasses import dataclass
from threading import Event, Lock
from typing import Optional

try:
    import paho.mqtt.client as mqtt
except ImportError:
    raise ImportError("paho-mqtt is required. Install with: pip install paho-mqtt")

from ..contracts.transport import TransportProtocol
from ..errors import TransportError

logger = logging.getLogger(__name__)


@dataclass
class MQTTConfig:
    """MQTT connection configuration."""

    broker: str = "iot.bluettipower.com"
    port: int = 18760
    device_sn: str = ""
    pfx_cert: Optional[bytes] = None
    cert_password: Optional[str] = None
    keepalive: int = 60


class MQTTTransport(TransportProtocol):
    """MQTT transport for Bluetti devices.

    Minimal implementation for Day 4:
    - Synchronous send_frame() with response wait
    - Single request at a time (no pipelining)
    - 5 second timeout

    Topic naming (from device perspective):
    - Device publishes to: PUB/{device_sn}
    - Device subscribes to: SUB/{device_sn}

    From client perspective (we are client):
    - We subscribe to: PUB/{device_sn}  ← Receive responses here
    - We publish to: SUB/{device_sn}    ← Send requests here
    """

    def __init__(self, config: MQTTConfig):
        """Initialize MQTT transport.

        Args:
            config: MQTT configuration
        """
        self.config = config
        self._client: Optional[mqtt.Client] = None
        self._connected = False
        self._connect_event = Event()
        self._connect_rc: Optional[int] = None

        # Response handling
        self._response_event = Event()
        self._response_data: Optional[bytes] = None
        self._response_lock = Lock()
        self._waiting = False  # Flag to filter unexpected responses

        # Request serialization (enforce "single request at a time")
        self._request_lock = Lock()

        # Topics
        self._subscribe_topic = f"PUB/{config.device_sn}"  # Device publishes here
        self._publish_topic = f"SUB/{config.device_sn}"  # Device subscribes here

        # SSL context
        self._ssl_context: Optional[ssl.SSLContext] = None

        # Temp files for certificates
        self._temp_cert_file: Optional[str] = None
        self._temp_key_file: Optional[str] = None

    def connect(self):
        """Connect to MQTT broker.

        Steps:
        1. Extract PFX certificate
        2. Create SSL context
        3. Connect to broker
        4. Subscribe to response topic

        Raises:
            TransportError: If connection fails
        """
        logger.info(
            f"Connecting to MQTT broker: {self.config.broker}:{self.config.port}"
        )

        try:
            # Extract certificate from PFX
            self._setup_ssl()
            self._connect_event.clear()
            self._connect_rc = None

            # Create MQTT client
            self._client = mqtt.Client(
                client_id=f"bluetti_v2_{self.config.device_sn}", protocol=mqtt.MQTTv311
            )

            # Set callbacks
            self._client.on_connect = self._on_connect
            self._client.on_message = self._on_message
            self._client.on_disconnect = self._on_disconnect

            # Configure TLS
            if self._ssl_context:
                self._client.tls_set_context(self._ssl_context)

            # Connect
            self._client.connect(
                self.config.broker, self.config.port, keepalive=self.config.keepalive
            )

            # Start network loop
            self._client.loop_start()

            # Wait for connect callback (with timeout)
            if not self._connect_event.wait(10.0):
                raise TransportError("Connection timeout")

            if not self._connected:
                rc = self._connect_rc
                raise TransportError(f"Connection failed (rc={rc})")

            logger.info("Connected to MQTT broker")

        except Exception as e:
            # Clean up temp certificates on failure
            self._cleanup_certs()
            raise TransportError(f"Failed to connect: {e}")

    def disconnect(self):
        """Disconnect from MQTT broker."""
        logger.info("Disconnecting from MQTT broker...")

        try:
            if self._client:
                if self._connected:
                    self._client.unsubscribe(self._subscribe_topic)
                    self._client.disconnect()
                self._client.loop_stop()
        finally:
            # Always clean up temp certificate files and reset state
            self._cleanup_certs()
            self._connected = False
            logger.info("Disconnected")

    def is_connected(self) -> bool:
        """Check if connected to broker.

        Returns:
            True if connected
        """
        return self._connected

    def send_frame(self, frame: bytes, timeout: float = 5.0) -> bytes:
        """Send Modbus frame and wait for response.

        This is synchronous and thread-safe (single request at a time):
        1. Publish frame to SUB/{device_sn}
        2. Wait for response on PUB/{device_sn}
        3. Return response

        Args:
            frame: Modbus RTU frame (with CRC)
            timeout: Timeout in seconds

        Returns:
            Response frame (with CRC)

        Raises:
            TransportError: If send fails or timeout
        """
        # Serialize all requests - only one at a time
        with self._request_lock:
            if not self._connected:
                raise TransportError("Not connected to MQTT broker")

            # Reset response event and mark that we're waiting for response
            with self._response_lock:
                self._response_event.clear()
                self._response_data = None
                self._waiting = True  # Start expecting response

            try:
                # Publish request
                logger.debug(f"Publishing to {self._publish_topic}: {frame.hex()}")

                try:
                    result = self._client.publish(
                        self._publish_topic,
                        payload=frame,
                        qos=1,  # At least once delivery
                    )

                    # Wait for publish to complete
                    result.wait_for_publish()

                except Exception as e:
                    raise TransportError(f"Failed to publish: {e}")

                # Wait for response
                logger.debug(f"Waiting for response (timeout={timeout}s)...")

                if not self._response_event.wait(timeout):
                    raise TransportError(f"Response timeout after {timeout}s")

                # Get response
                with self._response_lock:
                    if self._response_data is None:
                        raise TransportError("No response data received")

                    response = self._response_data
                    self._response_data = None

                logger.debug(f"Received response: {response.hex()}")

                return response

            finally:
                # Always clear waiting flag, even on timeout/exception
                with self._response_lock:
                    self._waiting = False

    def _setup_ssl(self):
        """Setup SSL context from PFX certificate.

        Raises:
            TransportError: If certificate setup fails
        """
        if not self.config.pfx_cert or not self.config.cert_password:
            logger.warning("No certificate provided, attempting insecure connection")
            return

        try:
            from cryptography.hazmat.primitives.serialization import pkcs12

            # Load PFX
            private_key, certificate, ca_certs = pkcs12.load_key_and_certificates(
                self.config.pfx_cert, self.config.cert_password.encode()
            )

            # Create temp files for cert and key
            # (paho-mqtt requires file paths, not in-memory objects)
            with tempfile.NamedTemporaryFile(
                mode="wb", delete=False, suffix=".pem"
            ) as cert_file:
                from cryptography.hazmat.primitives import serialization

                # Write certificate
                cert_file.write(certificate.public_bytes(serialization.Encoding.PEM))
                self._temp_cert_file = cert_file.name

            with tempfile.NamedTemporaryFile(
                mode="wb", delete=False, suffix=".pem"
            ) as key_file:
                # Write private key
                key_file.write(
                    private_key.private_bytes(
                        encoding=serialization.Encoding.PEM,
                        format=serialization.PrivateFormat.TraditionalOpenSSL,
                        encryption_algorithm=serialization.NoEncryption(),
                    )
                )
                self._temp_key_file = key_file.name

            # Create SSL context
            self._ssl_context = ssl.create_default_context()
            self._ssl_context.load_cert_chain(
                certfile=self._temp_cert_file, keyfile=self._temp_key_file
            )

            logger.info("SSL certificates loaded successfully")

        except Exception as e:
            raise TransportError(f"Failed to setup SSL: {e}")

    def _cleanup_certs(self):
        """Clean up temporary certificate files."""
        for temp_file in [self._temp_cert_file, self._temp_key_file]:
            if temp_file and os.path.exists(temp_file):
                try:
                    os.unlink(temp_file)
                except Exception as e:
                    logger.warning(f"Failed to delete temp file {temp_file}: {e}")

    def _on_connect(self, client, userdata, flags, rc):
        """MQTT connect callback."""
        if rc == 0:
            logger.info(f"Connected to MQTT broker (rc={rc})")

            # Subscribe to response topic
            client.subscribe(self._subscribe_topic, qos=1)
            logger.info(f"Subscribed to {self._subscribe_topic}")

            self._connected = True
            self._connect_rc = rc
            self._connect_event.set()
        else:
            logger.error(f"Connection failed (rc={rc})")
            self._connected = False
            self._connect_rc = rc
            self._connect_event.set()

    def _on_message(self, client, userdata, msg):
        """MQTT message callback."""
        logger.debug(f"Received message on {msg.topic}: {len(msg.payload)} bytes")

        # Check if we're expecting a response
        with self._response_lock:
            if not self._waiting:
                logger.debug(
                    "Ignoring unexpected response (not waiting for any request)"
                )
                return

        # Validate response before storing
        payload = msg.payload

        # Transport layer: just store the raw response.
        # Protocol validation (CRC, function code, length) happens in protocol layer.
        # This keeps transport layer focused on MQTT communication only.

        # Store response and signal event
        with self._response_lock:
            # Double-check we're still waiting (could have timed out)
            if self._waiting:
                self._response_data = payload
                self._response_event.set()
            else:
                logger.debug("Ignoring late response (request already timed out)")

    def _on_disconnect(self, client, userdata, rc):
        """MQTT disconnect callback."""
        logger.info(f"Disconnected from MQTT broker (rc={rc})")
        self._connected = False
=== КОНЕЦ ФАЙЛА: bluetti_sdk/transport/mqtt.py ===

=== НАЧАЛО ФАЙЛА: examples/basic_usage.py ===
"""Basic SDK usage example.

Demonstrates simple grid monitoring with Block 1300.

Key features:
- Auto-registration of schemas from SchemaRegistry
- No manual schema registration needed
- Simple MQTT transport setup
"""

import getpass
import logging

# Import auth from old code temporarily
import sys

from bluetti_sdk import BluettiClient, MQTTConfig, MQTTTransport
from bluetti_sdk.models.profiles import get_device_profile

sys.path.insert(0, "../")
from bluetti_mqtt_client import BluettiAuth


def main():
    """Main example."""

    # Setup logging
    logging.basicConfig(level=logging.INFO, format="%(levelname)s - %(message)s")

    logger = logging.getLogger(__name__)

    print("=== Bluetti SDK - Basic Usage Example ===\n")

    # Get credentials
    email = input("Email: ")
    password = getpass.getpass("Password: ")
    device_sn = input("Device SN: ")

    # Authenticate and get certificate
    logger.info("Authenticating with Bluetti API...")
    auth = BluettiAuth(email, password)

    if not auth.login():
        logger.error("Login failed")
        return

    pfx_data, cert_password = auth.get_certificate()

    if not pfx_data:
        logger.error("Failed to get certificate")
        return

    logger.info(f"Certificate downloaded ({len(pfx_data)} bytes)")

    # Create MQTT transport
    config = MQTTConfig(
        device_sn=device_sn, pfx_cert=pfx_data, cert_password=cert_password
    )

    transport = MQTTTransport(config)

    # Get device profile
    profile = get_device_profile("EL100V2")  # or "EL30V2", "Elite 200 V2"

    # Create client
    # Note: Schemas are auto-registered from device profile
    # No need for manual schema registration!
    client = BluettiClient(transport=transport, profile=profile, device_address=1)

    # Connect
    logger.info("Connecting to device...")
    client.connect()

    # Read Block 1300
    logger.info("Reading grid information...")
    grid_data = client.read_block(1300, register_count=16)

    # Display results
    print("\n📊 Grid Status:")
    print(f"  Frequency:  {grid_data.values['frequency']:.1f} Hz")
    print(f"  Voltage:    {grid_data.values['phase_0_voltage']:.1f} V")
    print(f"  Current:    {grid_data.values['phase_0_current']:.1f} A")
    print(f"  Power:      {grid_data.values['phase_0_power']} W")

    # Disconnect
    client.disconnect()

    print("\n✅ Example complete!")


if __name__ == "__main__":
    main()
=== КОНЕЦ ФАЙЛА: examples/basic_usage.py ===

=== НАЧАЛО ФАЙЛА: setup.py ===
"""Setup script for Bluetti SDK."""

import os

from setuptools import find_packages, setup

# Read long description from README
readme_path = os.path.join(os.path.dirname(__file__), "README.md")
if os.path.exists(readme_path):
    with open(readme_path, encoding="utf-8") as f:
        long_description = f.read()
else:
    long_description = "Official Python SDK for Bluetti Elite V2 power stations"

setup(
    name="bluetti-sdk",
    version="2.0.0",
    author="Zeus Fabric Team",
    author_email="",
    description="Official Python SDK for Bluetti Elite V2 power stations",
    long_description=long_description,
    long_description_content_type="text/markdown",
    url="https://github.com/yourusername/bluetti-sdk",
    packages=find_packages(exclude=["tests", "tests.*", "tools", "docs"]),
    classifiers=[
        "Development Status :: 4 - Beta",
        "Intended Audience :: Developers",
        "License :: OSI Approved :: MIT License",
        "Programming Language :: Python :: 3",
        "Programming Language :: Python :: 3.8",
        "Programming Language :: Python :: 3.9",
        "Programming Language :: Python :: 3.10",
        "Programming Language :: Python :: 3.11",
        "Topic :: Home Automation",
        "Topic :: System :: Hardware",
    ],
    python_requires=">=3.8",
    install_requires=[
        "paho-mqtt>=1.6.0",
        "cryptography>=3.4",
    ],
    extras_require={
        "dev": [
            "pytest>=7.0",
            "pytest-cov>=3.0",
            "black>=22.0",
            "flake8>=4.0",
            "mypy>=0.950",
        ],
    },
    # CLI tools coming in v2.1.0
    # entry_points={
    #     "console_scripts": [
    #         "bluetti-cli=bluetti_sdk.cli:main",
    #     ],
    # },
)
=== КОНЕЦ ФАЙЛА: setup.py ===

=== НАЧАЛО ФАЙЛА: tests/__init__.py ===
"""Test suite for Bluetti SDK."""
=== КОНЕЦ ФАЙЛА: tests/__init__.py ===

=== НАЧАЛО ФАЙЛА: tests/integration/__init__.py ===

=== КОНЕЦ ФАЙЛА: tests/integration/__init__.py ===

=== НАЧАЛО ФАЙЛА: tests/integration/test_mqtt_block_1300.py ===
"""End-to-End Test: Read Block 1300 via MQTT

Tests complete stack:
    MQTT Transport → Protocol → V2 Parser → Device Model

This is the "Hello World" for the V2 system.
"""

import getpass
import logging
import sys

# Import existing auth from research folder
sys.path.insert(0, "_research/old_code")
from bluetti_mqtt_client import BluettiAuth

# Import SDK
from bluetti_sdk import BluettiClient, MQTTConfig, MQTTTransport
from bluetti_sdk.devices.profiles import get_device_profile
from bluetti_sdk.protocol.v2.datatypes import Int16, UInt16
from bluetti_sdk.protocol.v2.schema import BlockSchema, Field


def create_block_1300_schema() -> BlockSchema:
    """Create Block 1300 schema (Grid Info).

    Based on BLOCK_1300_INV_GRID_INFO.md from reverse engineering.
    """
    return BlockSchema(
        block_id=1300,
        name="INV_GRID_INFO",
        description="Grid input monitoring",
        min_length=32,
        fields=[
            Field(
                name="frequency",
                offset=0,
                type=UInt16(),
                transform=["scale:0.1"],
                unit="Hz",
                required=True,
                description="Grid frequency",
            ),
            Field(
                name="phase_0_power",
                offset=26,
                type=Int16(),
                transform=["abs"],
                unit="W",
                required=True,
                description="Phase 0 power",
            ),
            Field(
                name="phase_0_voltage",
                offset=28,
                type=UInt16(),
                transform=["scale:0.1"],
                unit="V",
                required=True,
                description="Phase 0 voltage",
            ),
            Field(
                name="phase_0_current",
                offset=30,
                type=Int16(),
                transform=["abs", "scale:0.1"],
                unit="A",
                required=True,
                description="Phase 0 current",
            ),
        ],
        strict=True,
        schema_version="1.0.0",
    )


def main():
    """End-to-end test."""

    # Setup logging
    logging.basicConfig(
        level=logging.INFO,
        format="%(asctime)s - %(name)s - %(levelname)s - %(message)s",
    )

    print("=" * 60)
    print("V2 End-to-End Test - Block 1300 (Grid Info)")
    print("=" * 60)

    # === Step 1: Get credentials ===
    print("\n[Step 1] Authentication")
    print("-" * 60)

    email = input("Email: ")
    password = getpass.getpass("Password: ")
    device_sn = input("Device SN: ")
    device_model = input("Device model (EL100V2/EL30V2): ") or "EL100V2"

    # === Step 2: Login and get certificate ===
    print("\n[Step 2] Getting certificate...")
    print("-" * 60)

    auth = BluettiAuth(email, password)

    if not auth.login():
        print("❌ Login failed")
        return

    pfx_data, cert_password = auth.get_certificate()

    if not pfx_data:
        print("❌ Failed to get certificate")
        return

    print(f"✓ Certificate downloaded ({len(pfx_data)} bytes)")
    print(f"✓ Password: {cert_password}")

    # === Step 3: Create transport ===
    print("\n[Step 3] Creating MQTT transport...")
    print("-" * 60)

    mqtt_config = MQTTConfig(
        device_sn=device_sn, pfx_cert=pfx_data, cert_password=cert_password
    )

    transport = MQTTTransport(mqtt_config)

    # === Step 4: Get device profile ===
    print("\n[Step 4] Loading device profile...")
    print("-" * 60)

    try:
        profile = get_device_profile(device_model)
        print(f"✓ Model: {profile.model}")
        print(f"✓ Type ID: {profile.type_id}")
        print(f"✓ Protocol: {profile.protocol}")
        print(f"✓ Groups: {list(profile.groups.keys())}")
    except ValueError as e:
        print(f"❌ {e}")
        return

    # === Step 5: Create V2 client ===
    print("\n[Step 5] Creating V2 client...")
    print("-" * 60)

    client = BluettiClient(
        transport=transport,
        profile=profile,
        device_address=1,  # Modbus slave address
    )

    # === Step 6: Register Block 1300 schema ===
    print("\n[Step 6] Registering Block 1300 schema...")
    print("-" * 60)

    schema_1300 = create_block_1300_schema()
    client.register_schema(schema_1300)

    print(f"✓ Schema registered: {schema_1300.name}")
    print(f"✓ Fields: {len(schema_1300.fields)}")
    print(f"✓ Min length: {schema_1300.min_length} bytes")

    # === Step 7: Connect to device ===
    print("\n[Step 7] Connecting to device...")
    print("-" * 60)

    try:
        client.connect()
        print("✓ Connected")
    except Exception as e:
        print(f"❌ Connection failed: {e}")
        return

    # === Step 8: Read Block 1300 ===
    print("\n[Step 8] Reading Block 1300 (Grid Info)...")
    print("-" * 60)

    try:
        # Read block
        # Block 1300 needs 32 bytes = 16 registers
        parsed = client.read_block(1300, register_count=16)

        print("✓ Block read successfully")
        print(f"  Block ID: {parsed.block_id}")
        print(f"  Name: {parsed.name}")
        print(f"  Fields parsed: {len(parsed.values)}")
        print(f"  Data length: {parsed.length} bytes")

    except Exception as e:
        print(f"❌ Read failed: {e}")
        import traceback

        traceback.print_exc()

        # Disconnect before exit
        try:
            client.disconnect()
        except Exception:
            pass

        return

    # === Step 9: Display results ===
    print("\n[Step 9] Parsed Values")
    print("-" * 60)

    print("\n📊 Grid Status:")
    print(f"  Frequency:     {parsed.values['frequency']:.1f} Hz")
    print(f"  Voltage:       {parsed.values['phase_0_voltage']:.1f} V")
    print(f"  Current:       {parsed.values['phase_0_current']:.1f} A")
    print(f"  Power:         {parsed.values['phase_0_power']} W")

    # === Step 10: Validate results ===
    print("\n[Step 10] Validation")
    print("-" * 60)

    frequency = parsed.values["frequency"]
    voltage = parsed.values["phase_0_voltage"]

    # Sanity checks
    issues = []

    if not (45.0 <= frequency <= 55.0):
        issues.append(f"Frequency out of range: {frequency} Hz (expected 45-55)")

    if not (200.0 <= voltage <= 250.0):
        issues.append(f"Voltage out of range: {voltage} V (expected 200-250)")

    if issues:
        print("⚠️  Validation warnings:")
        for issue in issues:
            print(f"  - {issue}")
    else:
        print("✓ All values in expected ranges")

    # === Step 11: Check device state ===
    print("\n[Step 11] Device State")
    print("-" * 60)

    state = client.get_device_state()

    print(f"Device: {state['model']}")
    print(f"Last update: {state['last_update']}")
    print(f"Grid voltage: {state.get('grid_voltage')} V")
    print(f"Grid frequency: {state.get('grid_frequency')} Hz")

    # === Step 12: Disconnect ===
    print("\n[Step 12] Disconnecting...")
    print("-" * 60)

    try:
        client.disconnect()
        print("✓ Disconnected")
    except Exception as e:
        print(f"⚠️  Disconnect warning: {e}")

    # === Summary ===
    print("\n" + "=" * 60)
    print("✅ End-to-End Test COMPLETE")
    print("=" * 60)

    print("\nKey achievements:")
    print("✓ MQTT connection established")
    print("✓ Block 1300 read successfully")
    print("✓ Modbus framing handled correctly")
    print("✓ V2 parser extracted fields")
    print("✓ Device model updated")
    print("✓ Values validated")

    print("\nNext steps:")
    print("- Implement Block 100 (Dashboard data)")
    print("- Implement Block 6000 (Battery pack)")
    print("- Add continuous polling")
    print("- Integrate with Home Assistant")

    print("\n" + "=" * 60)


if __name__ == "__main__":
    main()
=== КОНЕЦ ФАЙЛА: tests/integration/test_mqtt_block_1300.py ===

=== НАЧАЛО ФАЙЛА: tests/integration/test_v2_integration.py ===
"""Simple integration test for V2 parser

Tests the core V2 parser without complex dependencies.
"""

from bluetti_sdk.protocol.v2.datatypes import Int16, UInt16
from bluetti_sdk.protocol.v2.parser import V2Parser
from bluetti_sdk.protocol.v2.schema import BlockSchema, Field


def test_grid_info_parsing():
    """Test parsing Block 1300 (Grid info)."""

    print("=" * 60)
    print("V2 Parser Integration Test - Block 1300 (Grid Info)")
    print("=" * 60)

    # Create schema for Block 1300
    schema = BlockSchema(
        block_id=1300,
        name="INV_GRID_INFO",
        description="Grid input monitoring",
        min_length=32,
        fields=[
            Field(
                name="frequency",
                offset=0,
                type=UInt16(),
                transform=["scale:0.1"],
                unit="Hz",
                required=True,
                description="Grid frequency",
            ),
            Field(
                name="phase_0_voltage",
                offset=28,
                type=UInt16(),
                transform=["scale:0.1"],
                unit="V",
                required=True,
                description="Phase 0 voltage",
            ),
            Field(
                name="phase_0_current",
                offset=30,
                type=Int16(),
                transform=["abs", "scale:0.1"],
                unit="A",
                required=True,
                description="Phase 0 current",
            ),
        ],
        strict=True,
        schema_version="1.0.0",
    )

    print("\n1. Schema created:")
    print(f"   Block ID: {schema.block_id}")
    print(f"   Name: {schema.name}")
    print(f"   Fields: {len(schema.fields)}")

    # Create parser and register schema
    parser = V2Parser()
    parser.register_schema(schema)

    print("\n2. Parser initialized:")
    print(f"   Registered schemas: {parser.list_schemas()}")

    # Create mock data (normalized Modbus payload)
    # Frequency: 500 (50.0 Hz)
    # Voltage: 2300 (230.0 V)
    # Current: -52 (5.2 A)
    data = bytearray(32)
    data[0:2] = bytes([0x01, 0xF4])  # offset 0: frequency = 500
    data[28:30] = bytes([0x08, 0xFC])  # offset 28: voltage = 2300
    data[30:32] = bytes([0xFF, 0xCC])  # offset 30: current = -52

    print("\n3. Mock data created:")
    print(f"   Data length: {len(data)} bytes")
    print(f"   Data (hex): {bytes(data).hex()}")

    # Parse block
    parsed = parser.parse_block(1300, bytes(data))

    print("\n4. Block parsed successfully:")
    print(f"   Block ID: {parsed.block_id}")
    print(f"   Name: {parsed.name}")
    print(f"   Timestamp: {parsed.timestamp}")
    print(f"   Fields parsed: {len(parsed.values)}")

    print("\n5. Parsed values:")
    for field_name, value in parsed.values.items():
        field = schema.get_field(field_name)
        unit = field.unit if field else ""
        print(f"   {field_name}: {value} {unit}")

    # Validate results
    print("\n6. Validation:")
    assert parsed.values["frequency"] == 50.0, "Frequency mismatch"
    print(f"   ✓ Frequency: {parsed.values['frequency']} Hz")

    assert parsed.values["phase_0_voltage"] == 230.0, "Voltage mismatch"
    print(f"   ✓ Voltage: {parsed.values['phase_0_voltage']} V")

    assert parsed.values["phase_0_current"] == 5.2, "Current mismatch"
    print(f"   ✓ Current: {parsed.values['phase_0_current']} A")

    # Test to_dict()
    dict_output = parsed.to_dict()
    print("\n7. Dictionary output:")
    print(f"   {dict_output}")

    print("\n" + "=" * 60)
    print("✓ All tests passed!")
    print("=" * 60)

    print("\nKey achievements:")
    print("✓ Schema definition works")
    print("✓ Transform pipeline works (scale, abs)")
    print("✓ Parser correctly extracts fields")
    print("✓ Validation passes")
    print("✓ Output formats work (values dict, to_dict())")


if __name__ == "__main__":
    test_grid_info_parsing()
=== КОНЕЦ ФАЙЛА: tests/integration/test_v2_integration.py ===

=== НАЧАЛО ФАЙЛА: tests/unit/models/test_device.py ===
"""Unit tests for device model."""

import time
from datetime import datetime

from bluetti_sdk.models.device import BatteryPackInfo, GridInfo, HomeData, V2Device
from bluetti_sdk.models.types import BlockGroup
from bluetti_sdk.protocol.v2.types import ParsedBlock


def test_grid_info_creation():
    """Test GridInfo dataclass creation."""
    grid = GridInfo(
        frequency=50.0, phase_0_voltage=230.4, phase_0_current=5.2, phase_0_power=1196
    )

    assert grid.frequency == 50.0
    assert grid.phase_0_voltage == 230.4
    assert grid.phase_0_current == 5.2
    assert grid.phase_0_power == 1196


def test_home_data_creation():
    """Test HomeData dataclass creation."""
    home = HomeData(soc=85, pack_voltage=51.2, pack_current=10.5, pack_power=537)

    assert home.soc == 85
    assert home.pack_voltage == 51.2
    assert home.pack_current == 10.5
    assert home.pack_power == 537


def test_battery_pack_info_creation():
    """Test BatteryPackInfo dataclass creation."""
    pack = BatteryPackInfo(
        soc=85,
        voltage=51.2,
        current=10.5,
        power=537,
        temp_max=35,
        temp_min=20,
        temp_avg=28,
        cycles=42,
        soh=98,
    )

    assert pack.soc == 85
    assert pack.voltage == 51.2
    assert pack.cycles == 42
    assert pack.soh == 98


def test_v2device_creation():
    """Test V2Device creation."""
    device = V2Device(model="EL100V2", device_id="test_device_001")

    assert device.model == "EL100V2"
    assert device.device_id == "test_device_001"
    # State containers are created but empty
    assert device.grid_info is not None
    assert device.home_data is not None
    assert device.battery_pack is not None
    assert device.grid_info.frequency is None  # Not yet updated


def test_v2device_update_grid_info():
    """Test updating grid info from parsed block."""
    device = V2Device(model="EL100V2", device_id="test_device_001")

    # Create parsed block (Block 1300)
    parsed = ParsedBlock(
        block_id=1300,
        name="INV_GRID_INFO",
        length=32,
        values={
            "frequency": 50.0,
            "phase_0_voltage": 230.4,
            "phase_0_current": 5.2,
            "phase_0_power": 1196,
        },
        raw=bytes(32),
        timestamp=time.time(),
    )

    device.update_from_block(parsed)

    # Grid info should be updated
    assert device.grid_info is not None
    assert device.grid_info.frequency == 50.0
    assert device.grid_info.phase_0_voltage == 230.4
    assert device.grid_info.phase_0_current == 5.2
    assert device.grid_info.phase_0_power == 1196


def test_v2device_update_home_data():
    """Test updating home data from parsed block."""
    device = V2Device(model="EL100V2", device_id="test_device_001")

    # Create parsed block (Block 100)
    parsed = ParsedBlock(
        block_id=100,
        name="APP_HOME_DATA",
        length=100,
        values={
            "soc": 85,
            "pack_voltage": 51.2,
            "pack_current": 10.5,
            "pack_power": 537,
            "ac_input_power": 0,
            "ac_output_power": 500,
            "dc_input_power": 100,
            "pv_power": 100,
        },
        raw=bytes(100),
        timestamp=time.time(),
    )

    device.update_from_block(parsed)

    # Home data should be updated
    assert device.home_data is not None
    assert device.home_data.soc == 85
    assert device.home_data.pack_voltage == 51.2
    assert device.home_data.ac_output_power == 500
    assert device.home_data.pv_power == 100


def test_v2device_update_battery_pack():
    """Test updating battery pack from parsed block."""
    device = V2Device(model="EL100V2", device_id="test_device_001")

    # Create parsed block (Block 6000)
    parsed = ParsedBlock(
        block_id=6000,
        name="PACK_MAIN_INFO",
        length=50,
        values={
            "soc": 85,
            "voltage": 51.2,
            "current": 10.5,
            "power": 537,
            "temp_max": 35,
            "temp_min": 20,
            "temp_avg": 28,
            "cycles": 42,
            "soh": 98,
        },
        raw=bytes(50),
        timestamp=time.time(),
    )

    device.update_from_block(parsed)

    # Battery pack should be updated
    assert device.battery_pack is not None
    assert device.battery_pack.soc == 85
    assert device.battery_pack.voltage == 51.2
    assert device.battery_pack.cycles == 42
    assert device.battery_pack.soh == 98


def test_v2device_update_unknown_block():
    """Test updating with unknown block ID."""
    device = V2Device(model="EL100V2", device_id="test_device_001")

    # Unknown block
    parsed = ParsedBlock(
        block_id=9999,
        name="UNKNOWN",
        length=10,
        values={"test": 123},
        raw=bytes(10),
        timestamp=time.time(),
    )

    # Should not raise, just log warning
    device.update_from_block(parsed)


def test_v2device_get_state_empty():
    """Test getting state when no data."""
    device = V2Device(model="EL100V2", device_id="test_device_001")

    state = device.get_state()

    assert state["model"] == "EL100V2"
    assert state["device_id"] == "test_device_001"
    assert state["last_update"] is None
    # Grid/home fields not included if not updated
    assert "grid_voltage" not in state
    assert "soc" not in state


def test_v2device_get_state_with_data():
    """Test getting state with data."""
    device = V2Device(model="EL100V2", device_id="test_device_001")

    # Add grid info
    device.grid_info = GridInfo(
        frequency=50.0,
        phase_0_voltage=230.4,
        phase_0_current=5.2,
        phase_0_power=1196,
        last_update=datetime.now(),  # Mark as updated
    )

    # Add home data
    device.home_data = HomeData(
        soc=85,
        pack_voltage=51.2,
        pack_current=10.5,
        pack_power=537,
        last_update=datetime.now(),  # Mark as updated
    )

    state = device.get_state()

    assert state["model"] == "EL100V2"
    assert state["grid_voltage"] == 230.4
    assert state["grid_frequency"] == 50.0
    # Note: grid_power from grid_info is overwritten by home_data.grid_power
    # so it will be None unless home_data.grid_power is set
    assert state["soc"] == 85
    assert state["pack_voltage"] == 51.2


def test_v2device_get_group_state_grid():
    """Test getting grid group state."""
    device = V2Device(model="EL100V2", device_id="test_device_001")

    device.grid_info = GridInfo(
        frequency=50.0, phase_0_voltage=230.4, phase_0_current=5.2, phase_0_power=1196
    )

    grid_state = device.get_group_state(BlockGroup.GRID)

    # Keys are simplified (no phase_0_ prefix)
    assert grid_state["frequency"] == 50.0
    assert grid_state["voltage"] == 230.4
    assert grid_state["current"] == 5.2
    assert grid_state["power"] == 1196


def test_v2device_get_group_state_core():
    """Test getting core group state."""
    device = V2Device(model="EL100V2", device_id="test_device_001")

    device.home_data = HomeData(
        soc=85, pack_voltage=51.2, pack_current=10.5, pack_power=537
    )

    core_state = device.get_group_state(BlockGroup.CORE)

    assert core_state["soc"] == 85
    assert core_state["pack_voltage"] == 51.2
    assert core_state["pack_power"] == 537


def test_v2device_get_group_state_battery():
    """Test getting battery group state."""
    device = V2Device(model="EL100V2", device_id="test_device_001")

    device.battery_pack = BatteryPackInfo(
        soc=85, voltage=51.2, current=10.5, power=537, cycles=42, soh=98
    )

    battery_state = device.get_group_state(BlockGroup.BATTERY)

    assert battery_state["soc"] == 85
    assert battery_state["voltage"] == 51.2
    assert battery_state["cycles"] == 42
    assert battery_state["soh"] == 98


def test_v2device_get_group_state_empty():
    """Test getting group state when no data."""
    device = V2Device(model="EL100V2", device_id="test_device_001")

    grid_state = device.get_group_state(BlockGroup.GRID)

    # Returns dict with None values
    assert "frequency" in grid_state
    assert "voltage" in grid_state
    assert grid_state["frequency"] is None
    assert grid_state["last_update"] is None


def test_v2device_last_update_tracking():
    """Test last update timestamp tracking."""
    device = V2Device(model="EL100V2", device_id="test_device_001")

    assert device.last_update is None

    # Update with block
    parsed = ParsedBlock(
        block_id=1300,
        name="INV_GRID_INFO",
        length=32,
        values={"frequency": 50.0},
        raw=bytes(32),
        timestamp=time.time(),
    )

    device.update_from_block(parsed)

    # Last update should be set (datetime object)
    assert device.last_update is not None
    assert isinstance(device.last_update, datetime)


def test_v2device_multiple_updates():
    """Test multiple sequential updates."""
    device = V2Device(model="EL100V2", device_id="test_device_001")

    # Update grid
    grid_block = ParsedBlock(
        block_id=1300,
        name="INV_GRID_INFO",
        length=32,
        values={"frequency": 50.0, "phase_0_voltage": 230.4},
        raw=bytes(32),
        timestamp=time.time(),
    )
    device.update_from_block(grid_block)

    # Update home
    home_block = ParsedBlock(
        block_id=100,
        name="APP_HOME_DATA",
        length=100,
        values={"soc": 85, "pack_voltage": 51.2},
        raw=bytes(100),
        timestamp=time.time(),
    )
    device.update_from_block(home_block)

    # Both should be updated
    assert device.grid_info is not None
    assert device.home_data is not None
    assert device.grid_info.frequency == 50.0
    assert device.home_data.soc == 85


def test_v2device_partial_data():
    """Test updating with partial data (optional fields)."""
    device = V2Device(model="EL100V2", device_id="test_device_001")

    # Minimal data
    parsed = ParsedBlock(
        block_id=1300,
        name="INV_GRID_INFO",
        length=32,
        values={
            "frequency": 50.0,
            # Missing other fields
        },
        raw=bytes(32),
        timestamp=time.time(),
    )

    device.update_from_block(parsed)

    # Should update with available data
    assert device.grid_info is not None
    assert device.grid_info.frequency == 50.0
    assert device.grid_info.phase_0_voltage is None
=== КОНЕЦ ФАЙЛА: tests/unit/models/test_device.py ===

=== НАЧАЛО ФАЙЛА: tests/unit/protocol/test_modbus.py ===
"""Unit tests for Modbus protocol layer."""

import pytest
from bluetti_sdk.errors import ProtocolError
from bluetti_sdk.protocol.modbus import (
    ModbusResponse,
    build_modbus_request,
    normalize_modbus_response,
    parse_modbus_frame,
    validate_crc,
)


def test_build_modbus_request():
    """Test building Modbus request."""
    # Read 10 registers starting from address 1300
    request = build_modbus_request(
        device_address=1, block_address=1300, register_count=10
    )

    # Check frame structure
    assert len(request) == 8  # 1 addr + 1 func + 2 start + 2 count + 2 crc
    assert request[0] == 0x01  # Device address
    assert request[1] == 0x03  # Function code (Read Holding Registers)

    # Check address (big-endian)
    assert (request[2] << 8 | request[3]) == 1300

    # Check count (big-endian)
    assert (request[4] << 8 | request[5]) == 10

    # CRC should be valid
    assert validate_crc(request)


def test_validate_crc():
    """Test CRC validation."""
    # Valid frame
    frame = build_modbus_request(1, 100, 5)
    assert validate_crc(frame) is True

    # Corrupt frame (flip one bit)
    corrupt = bytearray(frame)
    corrupt[0] ^= 0x01
    assert validate_crc(bytes(corrupt)) is False

    # Too short
    assert validate_crc(b"\x01\x03") is False


def test_parse_modbus_frame():
    """Test parsing Modbus frame."""
    # Build a valid response frame
    # [addr=01][func=03][count=06][data: 00 55 02 08 0C AD][crc]
    frame = bytes(
        [
            0x01,  # Device address
            0x03,  # Function code
            0x06,  # Byte count
            0x00,
            0x55,
            0x02,
            0x08,
            0x0C,
            0xAD,  # 6 bytes data
            0x00,
            0x00,  # Placeholder CRC (will be invalid but structure is correct)
        ]
    )

    response = parse_modbus_frame(frame)

    assert response.device_address == 0x01
    assert response.function_code == 0x03
    assert response.byte_count == 0x06
    assert response.data == bytes([0x00, 0x55, 0x02, 0x08, 0x0C, 0xAD])
    assert response.crc is not None


def test_parse_modbus_frame_too_short():
    """Test parsing frame that's too short."""
    with pytest.raises(ProtocolError, match="Frame too short"):
        parse_modbus_frame(b"\x01\x03")


def test_parse_modbus_frame_truncated():
    """Test parsing truncated frame."""
    # Frame says byte_count=10 but only has 2 bytes of data
    frame = bytes([0x01, 0x03, 0x0A, 0x00, 0x01])

    with pytest.raises(ProtocolError, match="Frame truncated"):
        parse_modbus_frame(frame)


def test_normalize_modbus_response():
    """Test normalizing Modbus response."""
    response = ModbusResponse(
        device_address=0x01,
        function_code=0x03,
        byte_count=6,
        data=bytes([0x00, 0x55, 0x02, 0x08, 0x0C, 0xAD]),
        crc=0xABCD,
    )

    normalized = normalize_modbus_response(response)

    # Should return clean data (no framing)
    assert normalized == bytes([0x00, 0x55, 0x02, 0x08, 0x0C, 0xAD])


def test_normalize_modbus_response_wrong_function_code():
    """Test normalizing with wrong function code."""
    response = ModbusResponse(
        device_address=0x01,
        function_code=0x04,  # Wrong (should be 0x03)
        byte_count=6,
        data=bytes([0x00, 0x55, 0x02, 0x08, 0x0C, 0xAD]),
    )

    with pytest.raises(ProtocolError, match="Unsupported function code"):
        normalize_modbus_response(response)


def test_normalize_modbus_response_byte_count_mismatch():
    """Test normalizing with byte count mismatch."""
    response = ModbusResponse(
        device_address=0x01,
        function_code=0x03,
        byte_count=10,  # Says 10 bytes
        data=bytes([0x00, 0x55, 0x02]),  # But only 3 bytes
    )

    with pytest.raises(ProtocolError, match="Byte count mismatch"):
        normalize_modbus_response(response)


def test_modbus_error_response():
    """Test handling Modbus error response (0x83)."""
    response = ModbusResponse(
        device_address=0x01,
        function_code=0x83,  # Error bit set (0x03 | 0x80)
        byte_count=1,
        data=bytes([0x02]),  # Error code: Illegal data address
    )

    with pytest.raises(ProtocolError, match="Illegal data address"):
        normalize_modbus_response(response)


def test_modbus_error_response_no_error_code():
    """Test error response with missing error code."""
    response = ModbusResponse(
        device_address=0x01,
        function_code=0x83,
        byte_count=0,
        data=bytes([]),  # No error code!
    )

    with pytest.raises(ProtocolError, match="missing error code"):
        normalize_modbus_response(response)


def test_modbus_error_codes():
    """Test all standard Modbus error codes."""
    error_codes = {
        0x01: "Illegal function",
        0x02: "Illegal data address",
        0x03: "Illegal data value",
        0x04: "Slave device failure",
    }

    for code, expected_msg in error_codes.items():
        response = ModbusResponse(
            device_address=0x01, function_code=0x83, byte_count=1, data=bytes([code])
        )

        with pytest.raises(ProtocolError, match=expected_msg):
            normalize_modbus_response(response)


def test_modbus_unknown_error_code():
    """Test unknown error code."""
    response = ModbusResponse(
        device_address=0x01,
        function_code=0x83,
        byte_count=1,
        data=bytes([0xFF]),  # Unknown error code
    )

    with pytest.raises(ProtocolError, match="Unknown error 255"):
        normalize_modbus_response(response)


def test_crc_calculation():
    """Test CRC calculation is consistent."""
    # Build two identical requests
    req1 = build_modbus_request(1, 1300, 16)
    req2 = build_modbus_request(1, 1300, 16)

    # Should be identical (including CRC)
    assert req1 == req2

    # CRC should be valid
    assert validate_crc(req1)
    assert validate_crc(req2)


def test_different_addresses_different_crc():
    """Test different data produces different CRC."""
    req1 = build_modbus_request(1, 1300, 16)
    req2 = build_modbus_request(1, 1301, 16)  # Different address

    # Should be different
    assert req1 != req2

    # Both should have valid CRC
    assert validate_crc(req1)
    assert validate_crc(req2)
=== КОНЕЦ ФАЙЛА: tests/unit/protocol/test_modbus.py ===

=== НАЧАЛО ФАЙЛА: tests/unit/protocol/v2/test_datatypes.py ===
"""Unit tests for V2 datatypes."""

import pytest
from bluetti_sdk.protocol.v2.datatypes import (
    Bitmap,
    Enum,
    Int8,
    Int16,
    Int32,
    String,
    UInt8,
    UInt16,
    UInt32,
)


def test_uint8():
    """Test UInt8 parsing and encoding."""
    dtype = UInt8()

    # Parse
    data = bytes([0, 42, 255])
    assert dtype.parse(data, 0) == 0
    assert dtype.parse(data, 1) == 42
    assert dtype.parse(data, 2) == 255

    # Encode
    assert dtype.encode(0) == b"\x00"
    assert dtype.encode(42) == b"\x2a"
    assert dtype.encode(255) == b"\xff"

    # Out of range
    with pytest.raises(ValueError):
        dtype.encode(256)
    with pytest.raises(ValueError):
        dtype.encode(-1)


def test_int8():
    """Test Int8 parsing and encoding."""
    dtype = Int8()

    # Parse
    data = bytes([0, 127, 128, 255])
    assert dtype.parse(data, 0) == 0
    assert dtype.parse(data, 1) == 127
    assert dtype.parse(data, 2) == -128
    assert dtype.parse(data, 3) == -1

    # Encode
    assert dtype.encode(0) == b"\x00"
    assert dtype.encode(127) == b"\x7f"
    assert dtype.encode(-128) == b"\x80"
    assert dtype.encode(-1) == b"\xff"


def test_uint16():
    """Test UInt16 parsing and encoding (big-endian)."""
    dtype = UInt16()

    # Parse (big-endian)
    data = bytes([0x00, 0x00, 0x12, 0x34, 0xFF, 0xFF])
    assert dtype.parse(data, 0) == 0
    assert dtype.parse(data, 2) == 0x1234
    assert dtype.parse(data, 4) == 65535

    # Encode
    assert dtype.encode(0) == b"\x00\x00"
    assert dtype.encode(0x1234) == b"\x12\x34"
    assert dtype.encode(65535) == b"\xff\xff"


def test_int16():
    """Test Int16 parsing and encoding (big-endian)."""
    dtype = Int16()

    # Parse
    data = bytes([0x00, 0x00, 0x7F, 0xFF, 0x80, 0x00, 0xFF, 0xFF])
    assert dtype.parse(data, 0) == 0
    assert dtype.parse(data, 2) == 32767
    assert dtype.parse(data, 4) == -32768
    assert dtype.parse(data, 6) == -1

    # Encode
    assert dtype.encode(0) == b"\x00\x00"
    assert dtype.encode(32767) == b"\x7f\xff"
    assert dtype.encode(-32768) == b"\x80\x00"
    assert dtype.encode(-1) == b"\xff\xff"


def test_uint32():
    """Test UInt32 parsing and encoding (big-endian)."""
    dtype = UInt32()

    # Parse
    data = bytes([0x00, 0x00, 0x00, 0x00, 0x12, 0x34, 0x56, 0x78])
    assert dtype.parse(data, 0) == 0
    assert dtype.parse(data, 4) == 0x12345678

    # Encode
    assert dtype.encode(0) == b"\x00\x00\x00\x00"
    assert dtype.encode(0x12345678) == b"\x12\x34\x56\x78"


def test_int32():
    """Test Int32 parsing and encoding (big-endian)."""
    dtype = Int32()

    # Parse
    data = bytes([0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF])
    assert dtype.parse(data, 0) == 0
    assert dtype.parse(data, 4) == -1

    # Encode
    assert dtype.encode(0) == b"\x00\x00\x00\x00"
    assert dtype.encode(-1) == b"\xff\xff\xff\xff"


def test_string():
    """Test String parsing and encoding."""
    dtype = String(10)

    # Parse (null-terminated)
    data = b"Hello\x00\x00\x00\x00\x00Test"
    assert dtype.parse(data, 0) == "Hello"

    # Parse (no null)
    data2 = b"HelloWorld"
    assert dtype.parse(data2, 0) == "HelloWorld"

    # Encode
    assert dtype.encode("Hello") == b"Hello\x00\x00\x00\x00\x00"
    assert dtype.encode("Test") == b"Test\x00\x00\x00\x00\x00\x00"

    # Too long
    with pytest.raises(ValueError):
        dtype.encode("ThisIsTooLong")


def test_bitmap():
    """Test Bitmap parsing."""
    # 8-bit
    dtype8 = Bitmap(8)
    data = bytes([0b10101010])
    assert dtype8.parse(data, 0) == 0b10101010

    # 16-bit
    dtype16 = Bitmap(16)
    data = bytes([0x12, 0x34])
    assert dtype16.parse(data, 0) == 0x1234

    # 32-bit
    dtype32 = Bitmap(32)
    data = bytes([0x12, 0x34, 0x56, 0x78])
    assert dtype32.parse(data, 0) == 0x12345678


def test_enum():
    """Test Enum parsing."""
    mapping = {0: "IDLE", 1: "CHARGING", 2: "DISCHARGING", 3: "FAULT"}

    dtype = Enum(mapping)

    # Parse known values
    data = bytes([0, 1, 2, 3, 99])
    assert dtype.parse(data, 0) == "IDLE"
    assert dtype.parse(data, 1) == "CHARGING"
    assert dtype.parse(data, 2) == "DISCHARGING"
    assert dtype.parse(data, 3) == "FAULT"

    # Parse unknown value
    assert dtype.parse(data, 4) == "UNKNOWN_99"

    # Encode
    assert dtype.encode("IDLE") == b"\x00"
    assert dtype.encode("CHARGING") == b"\x01"

    # Unknown value
    with pytest.raises(ValueError):
        dtype.encode("INVALID")


def test_offset_bounds():
    """Test that parsing respects offset boundaries."""
    dtype = UInt16()

    # Valid
    data = bytes([0x12, 0x34, 0x56])
    assert dtype.parse(data, 0) == 0x1234

    # Out of bounds
    with pytest.raises(IndexError):
        dtype.parse(data, 2)  # Would read bytes 2-3, but only 3 bytes total
=== КОНЕЦ ФАЙЛА: tests/unit/protocol/v2/test_datatypes.py ===

=== НАЧАЛО ФАЙЛА: tests/unit/protocol/v2/test_parser.py ===
"""Unit tests for V2 parser."""

import pytest
from bluetti_sdk.protocol.v2.datatypes import Int16, UInt16
from bluetti_sdk.protocol.v2.parser import V2Parser
from bluetti_sdk.protocol.v2.schema import (
    ArrayField,
    BlockSchema,
    Field,
    PackedField,
    SubField,
)


def test_basic_field_parsing():
    """Test parsing a simple field."""
    schema = BlockSchema(
        block_id=100,
        name="TEST_BLOCK",
        description="Test block",
        min_length=4,
        fields=[
            Field("soc", offset=0, type=UInt16(), unit="%"),
            Field(
                "voltage", offset=2, type=UInt16(), transform=["scale:0.1"], unit="V"
            ),
        ],
    )

    parser = V2Parser()
    parser.register_schema(schema)

    # SOC=85, voltage=520 (52.0V)
    data = bytes([0x00, 0x55, 0x02, 0x08])

    parsed = parser.parse_block(100, data)

    assert parsed.block_id == 100
    assert parsed.name == "TEST_BLOCK"
    assert parsed.values["soc"] == 85
    assert parsed.values["voltage"] == pytest.approx(52.0)


def test_array_field_parsing():
    """Test parsing an array field."""
    schema = BlockSchema(
        block_id=101,
        name="ARRAY_TEST",
        description="Array test",
        min_length=8,
        fields=[
            ArrayField(
                name="temperatures",
                offset=0,
                count=4,
                stride=2,
                item_type=UInt16(),
                transform=["minus:40"],
                unit="C",
            )
        ],
    )

    parser = V2Parser()
    parser.register_schema(schema)

    # Temps: 80, 75, 70, 65 (raw) → 40, 35, 30, 25 (C)
    data = bytes(
        [
            0x00,
            80,  # 40C
            0x00,
            75,  # 35C
            0x00,
            70,  # 30C
            0x00,
            65,  # 25C
        ]
    )

    parsed = parser.parse_block(101, data)

    assert parsed.values["temperatures"] == [40, 35, 30, 25]


def test_packed_field_parsing():
    """Test parsing a packed field (cell voltage + status)."""
    schema = BlockSchema(
        block_id=102,
        name="PACKED_TEST",
        description="Packed field test",
        min_length=4,
        fields=[
            PackedField(
                name="cells",
                offset=0,
                count=2,
                stride=2,
                base_type=UInt16(),
                fields=[
                    SubField(
                        "voltage", bits="0:14", transform=["scale:0.001"], unit="V"
                    ),
                    SubField("status", bits="14:16"),
                ],
            )
        ],
    )

    parser = V2Parser()
    parser.register_schema(schema)

    # Cell 0: voltage=3245mV, status=2
    # Cell 1: voltage=3256mV, status=1
    data = bytes(
        [
            0x80 | 0x0C,
            0xAD,  # 0x8CAD = 0b10001100 10101101 → status=2, voltage=3245
            0x40 | 0x0C,
            0xB8,  # 0x4CB8 = 0b01001100 10111000 → status=1, voltage=3256
        ]
    )

    parsed = parser.parse_block(102, data)

    cells = parsed.values["cells"]
    assert len(cells) == 2

    # Cell 0
    assert cells[0]["voltage"] == pytest.approx(3.245)
    assert cells[0]["status"] == 2

    # Cell 1
    assert cells[1]["voltage"] == pytest.approx(3.256)
    assert cells[1]["status"] == 1


def test_validation_strict_mode():
    """Test strict validation mode - should raise exception on validation failure."""
    from bluetti_sdk.errors import ParserError

    schema = BlockSchema(
        block_id=103,
        name="STRICT_TEST",
        description="Strict validation test",
        min_length=4,
        fields=[
            Field("value1", offset=0, type=UInt16(), required=True),
            Field("value2", offset=2, type=UInt16(), required=True),
        ],
        strict=True,
    )

    parser = V2Parser()
    parser.register_schema(schema)

    # Data too short - should raise ParserError in strict mode
    data_short = bytes([0x00, 0x01])

    with pytest.raises(ParserError, match="validation failed"):
        parser.parse_block(103, data_short, validate=True)


def test_validation_optional_fields():
    """Test optional fields in validation."""
    schema = BlockSchema(
        block_id=104,
        name="OPTIONAL_TEST",
        description="Optional fields test",
        min_length=2,
        fields=[
            Field("required_field", offset=0, type=UInt16(), required=True),
            Field("optional_field", offset=2, type=UInt16(), required=False),
        ],
        strict=False,
    )

    parser = V2Parser()
    parser.register_schema(schema)

    # Only required field present
    data = bytes([0x00, 0x42])

    parsed = parser.parse_block(104, data, validate=True)

    assert parsed.values["required_field"] == 66
    assert parsed.values["optional_field"] is None

    # Validation should pass
    assert parsed.validation is not None
    assert parsed.validation.valid
    assert "optional_field" in parsed.validation.missing_fields


def test_protocol_version_gating():
    """Test min_protocol_version field gating."""
    schema = BlockSchema(
        block_id=105,
        name="VERSION_TEST",
        description="Protocol version test",
        min_length=4,
        fields=[
            Field("always_present", offset=0, type=UInt16(), required=True),
            Field(
                "new_field",
                offset=2,
                type=UInt16(),
                required=False,
                min_protocol_version=2003,
            ),
        ],
    )

    parser = V2Parser()
    parser.register_schema(schema)

    data = bytes([0x00, 0x01, 0x00, 0x02])

    # Old protocol version - new_field should be None
    parsed_old = parser.parse_block(105, data, protocol_version=2000)
    assert parsed_old.values["always_present"] == 1
    assert parsed_old.values["new_field"] is None

    # New protocol version - new_field should be parsed
    parsed_new = parser.parse_block(105, data, protocol_version=2003)
    assert parsed_new.values["always_present"] == 1
    assert parsed_new.values["new_field"] == 2


def test_to_dict():
    """Test ParsedBlock.to_dict()."""
    schema = BlockSchema(
        block_id=106,
        name="DICT_TEST",
        description="Dict output test",
        min_length=4,
        fields=[
            Field("soc", offset=0, type=UInt16()),
            Field("voltage", offset=2, type=UInt16(), transform=["scale:0.1"]),
        ],
    )

    parser = V2Parser()
    parser.register_schema(schema)

    data = bytes([0x00, 0x50, 0x02, 0x08])  # SOC=80, voltage=52.0V

    parsed = parser.parse_block(106, data)
    dict_output = parsed.to_dict()

    assert dict_output == {"soc": 80, "voltage": pytest.approx(52.0)}


def test_grid_voltage_frequency_example():
    """Test real-world example: Block 1300 grid voltage/frequency."""
    schema = BlockSchema(
        block_id=1300,
        name="INV_GRID_INFO",
        description="Grid input monitoring",
        min_length=32,
        fields=[
            Field(
                "frequency", offset=0, type=UInt16(), transform=["scale:0.1"], unit="Hz"
            ),
            Field(
                "phase_0_voltage",
                offset=28,
                type=UInt16(),
                transform=["scale:0.1"],
                unit="V",
            ),
            Field(
                "phase_0_current",
                offset=30,
                type=Int16(),
                transform=["abs", "scale:0.1"],
                unit="A",
            ),
        ],
    )

    parser = V2Parser()
    parser.register_schema(schema)

    # Frequency: 500 (50.0 Hz)
    # Voltage: 2300 (230.0V)
    # Current: -52 (5.2A)
    data = bytearray(32)
    data[0:2] = bytes([0x01, 0xF4])  # 500 → 50.0 Hz
    data[28:30] = bytes([0x08, 0xFC])  # 2300 → 230.0V
    data[30:32] = bytes([0xFF, 0xCC])  # -52 → 5.2A

    parsed = parser.parse_block(1300, bytes(data))

    assert parsed.values["frequency"] == pytest.approx(50.0)
    assert parsed.values["phase_0_voltage"] == pytest.approx(230.0)
    assert parsed.values["phase_0_current"] == pytest.approx(5.2)


def test_parser_list_schemas():
    """Test listing registered schemas."""
    parser = V2Parser()

    schema1 = BlockSchema(
        block_id=100, name="BLOCK_A", description="Block A", min_length=10, fields=[]
    )

    schema2 = BlockSchema(
        block_id=200, name="BLOCK_B", description="Block B", min_length=20, fields=[]
    )

    parser.register_schema(schema1)
    parser.register_schema(schema2)

    schemas = parser.list_schemas()

    assert schemas == {100: "BLOCK_A", 200: "BLOCK_B"}


def test_parser_duplicate_registration():
    """Test that duplicate block_id registration raises error."""
    parser = V2Parser()

    schema1 = BlockSchema(
        block_id=100, name="BLOCK_A", description="Block A", min_length=10, fields=[]
    )

    schema2 = BlockSchema(
        block_id=100, name="BLOCK_B", description="Block B", min_length=20, fields=[]
    )

    parser.register_schema(schema1)

    with pytest.raises(ValueError, match="already registered"):
        parser.register_schema(schema2)


def test_parser_unknown_block():
    """Test parsing unknown block ID raises error."""
    parser = V2Parser()

    with pytest.raises(ValueError, match="No schema registered"):
        parser.parse_block(999, bytes([0x00, 0x01]))
=== КОНЕЦ ФАЙЛА: tests/unit/protocol/v2/test_parser.py ===

=== НАЧАЛО ФАЙЛА: tests/unit/protocol/v2/test_transforms.py ===
"""Unit tests for V2 transform pipeline."""

import pytest
from bluetti_sdk.protocol.v2.transforms import (
    TransformChain,
    TransformError,
    TransformStep,
    abs_,
    apply_transform,
    apply_transform_pipeline,
    bitmask,
    clamp,
    compile_transform_pipeline,
    minus,
    parse_transform_spec,
    scale,
    shift,
)


def test_transform_abs():
    """Test abs transform."""
    assert apply_transform("abs", -52) == 52
    assert apply_transform("abs", 42) == 42
    assert apply_transform("abs", 0) == 0


def test_transform_scale():
    """Test scale transform."""
    assert apply_transform("scale:0.1", 520) == 52.0
    assert apply_transform("scale:10", 5) == 50
    assert apply_transform("scale:0.001", 3245) == 3.245


def test_transform_minus():
    """Test minus transform."""
    assert apply_transform("minus:40", 80) == 40
    assert apply_transform("minus:40", 0) == -40
    assert apply_transform("minus:273.15", 300) == pytest.approx(26.85)


def test_transform_bitmask():
    """Test bitmask transform."""
    # Extract lower 14 bits
    assert apply_transform("bitmask:0x3FFF", 0xFFFF) == 0x3FFF
    assert apply_transform("bitmask:0x3FFF", 0xC000) == 0x0000

    # Extract upper 2 bits (need shift after)
    assert apply_transform("bitmask:0xC000", 0xFFFF) == 0xC000


def test_transform_shift():
    """Test shift transform."""
    assert apply_transform("shift:14", 0xC000) == 3
    assert apply_transform("shift:8", 0x1234) == 0x12
    assert apply_transform("shift:1", 8) == 4


def test_transform_clamp():
    """Test clamp transform."""
    assert apply_transform("clamp:0:100", 150) == 100
    assert apply_transform("clamp:0:100", -50) == 0
    assert apply_transform("clamp:0:100", 50) == 50


def test_pipeline_abs_scale():
    """Test pipeline: abs then scale."""
    pipeline = ["abs", "scale:0.1"]
    assert apply_transform_pipeline(pipeline, -52) == 5.2
    assert apply_transform_pipeline(pipeline, 520) == 52.0


def test_pipeline_bitmask_shift_scale():
    """Test complex pipeline: extract bits, shift, scale."""
    # Cell voltage encoding: 14-bit voltage + 2-bit status
    raw_value = 0xC000 | 3245  # status=3, voltage=3245mV

    # Extract voltage (lower 14 bits)
    voltage_pipeline = ["bitmask:0x3FFF", "scale:0.001"]
    voltage = apply_transform_pipeline(voltage_pipeline, raw_value)
    assert voltage == pytest.approx(3.245)

    # Extract status (upper 2 bits)
    status_pipeline = ["shift:14"]
    status = apply_transform_pipeline(status_pipeline, raw_value)
    assert status == 3


def test_pipeline_temperature():
    """Test temperature conversion pipeline."""
    # Temperature: raw_byte - 40 = temp_C
    pipeline = ["minus:40"]
    assert apply_transform_pipeline(pipeline, 80) == 40
    assert apply_transform_pipeline(pipeline, 20) == -20


def test_compile_pipeline():
    """Test compiled pipeline for performance."""
    specs = ["abs", "scale:0.1"]
    compiled = compile_transform_pipeline(specs)

    assert compiled(-52) == 5.2
    assert compiled(520) == 52.0


def test_parse_transform_spec():
    """Test transform spec parsing."""
    # No args
    name, args = parse_transform_spec("abs")
    assert name == "abs"
    assert args == []

    # Single arg
    name, args = parse_transform_spec("scale:0.1")
    assert name == "scale"
    assert args == ["0.1"]

    # Multiple args
    name, args = parse_transform_spec("clamp:0:100")
    assert name == "clamp"
    assert args == ["0", "100"]


def test_unknown_transform():
    """Test error on unknown transform."""
    with pytest.raises(TransformError, match="Unknown transform"):
        apply_transform("invalid_transform", 42)


def test_invalid_scale_factor():
    """Test error on invalid scale factor."""
    with pytest.raises(TransformError, match="Invalid scale factor"):
        apply_transform("scale:not_a_number", 42)


def test_invalid_bitmask():
    """Test error on invalid bitmask."""
    with pytest.raises(TransformError, match="Invalid bitmask"):
        apply_transform("bitmask:not_hex", 42)


def test_grid_current_example():
    """Test real-world example: grid current with abs and scale."""
    # Grid current: INT16, abs(), /10.0 → A
    # Raw value: -52 (negative indicates direction)
    raw_value = -52

    pipeline = ["abs", "scale:0.1"]
    current_a = apply_transform_pipeline(pipeline, raw_value)

    assert current_a == pytest.approx(5.2)


def test_cell_voltage_example():
    """Test real-world example: cell voltage extraction."""
    # Cell voltage: 16-bit packed value
    # Bits 0-13: voltage in mV
    # Bits 14-15: status
    raw_value = 0x8000 | 3245  # status=2, voltage=3245mV

    # Extract voltage
    voltage_pipeline = ["bitmask:0x3FFF", "scale:0.001"]
    voltage_v = apply_transform_pipeline(voltage_pipeline, raw_value)

    assert voltage_v == pytest.approx(3.245)

    # Extract status
    status_pipeline = ["bitmask:0xC000", "shift:14"]
    status = apply_transform_pipeline(status_pipeline, raw_value)

    assert status == 2


def test_typed_transform_step_to_spec():
    step = scale(0.1)
    assert isinstance(step, TransformStep)
    assert step.to_spec() == "scale:0.1"


def test_typed_transform_chain_pipe_operator():
    chain = abs_() | scale(0.1) | minus(2)
    assert isinstance(chain, TransformChain)
    assert chain.to_specs() == ["abs", "scale:0.1", "minus:2"]


def test_compile_pipeline_accepts_typed_chain():
    chain = bitmask(0x3FFF) | scale(0.001)
    compiled = compile_transform_pipeline([chain])
    assert compiled(3245) == pytest.approx(3.245)


def test_apply_pipeline_mixed_dsl_and_typed():
    result = apply_transform_pipeline(["abs", scale(0.1), clamp(0, 10)], -520)
    assert result == 10


def test_shift_typed_factory():
    assert shift(14).to_spec() == "shift:14"


def test_scale_factory_validation():
    with pytest.raises(ValueError, match="cannot be zero"):
        scale(0)
    with pytest.raises(ValueError, match="must be finite"):
        scale(float("inf"))


def test_clamp_factory_validation():
    with pytest.raises(ValueError, match="min must be < max"):
        clamp(10, 10)
    with pytest.raises(ValueError, match="min must be < max"):
        clamp(11, 10)
=== КОНЕЦ ФАЙЛА: tests/unit/protocol/v2/test_transforms.py ===

=== НАЧАЛО ФАЙЛА: tests/unit/test_client.py ===
"""Unit tests for V2Client orchestration layer."""

from unittest.mock import Mock

import pytest
from bluetti_sdk.client import V2Client
from bluetti_sdk.devices.profiles import get_device_profile
from bluetti_sdk.errors import TransportError
from bluetti_sdk.models.types import BlockGroup
from bluetti_sdk.protocol.v2.datatypes import UInt16
from bluetti_sdk.protocol.v2.schema import BlockSchema, Field
from bluetti_sdk.protocol.v2.types import ParsedBlock
from bluetti_sdk.schemas.registry import SchemaRegistry


@pytest.fixture
def mock_transport():
    """Create mock transport."""
    transport = Mock()
    transport.connect = Mock()
    transport.disconnect = Mock()
    transport.is_connected = Mock(return_value=True)
    transport.send_frame = Mock(
        return_value=bytes(
            [
                0x01,
                0x03,
                0x04,  # Header
                0x00,
                0x64,  # Data: 100
                0x00,
                0xC8,  # Data: 200
                0x00,
                0x00,  # CRC placeholder
            ]
        )
    )
    return transport


@pytest.fixture
def device_profile():
    """Get EL100V2 device profile."""
    return get_device_profile("EL100V2")


@pytest.fixture
def mock_schema():
    """Create mock schema."""
    schema = BlockSchema(
        block_id=1300,
        name="TEST_BLOCK",
        description="Test block for unit tests",
        min_length=4,
        fields=[
            Field(name="field1", offset=0, type=UInt16()),
            Field(name="field2", offset=2, type=UInt16()),
        ],
    )
    return schema


def test_client_creation(mock_transport, device_profile):
    """Test V2Client creation."""
    client = V2Client(
        transport=mock_transport, profile=device_profile, device_address=1
    )

    assert client.profile.model == "EL100V2"
    assert client.device is not None
    assert client.transport is mock_transport


def test_client_with_custom_device_address(mock_transport, device_profile):
    """Test V2Client with custom device address."""
    client = V2Client(
        transport=mock_transport, profile=device_profile, device_address=5
    )

    assert client.device_address == 5


def test_client_connect(mock_transport, device_profile):
    """Test client connect."""
    client = V2Client(transport=mock_transport, profile=device_profile)

    client.connect()

    mock_transport.connect.assert_called_once()


def test_client_disconnect(mock_transport, device_profile):
    """Test client disconnect."""
    client = V2Client(transport=mock_transport, profile=device_profile)

    client.disconnect()

    mock_transport.disconnect.assert_called_once()


def test_client_auto_registers_schemas(mock_transport, device_profile):
    """Test that schemas are auto-registered from SchemaRegistry."""
    client = V2Client(transport=mock_transport, profile=device_profile)

    # Schemas should be auto-registered for blocks in profile
    # EL100V2 profile has core=[100], grid=[1300], battery=[6000]
    assert client.parser.get_schema(100) is not None  # APP_HOME_DATA
    assert client.parser.get_schema(1300) is not None  # INV_GRID_INFO
    assert client.parser.get_schema(6000) is not None  # PACK_MAIN_INFO

    # Check names match
    assert client.parser.get_schema(100).name == "APP_HOME_DATA"
    assert client.parser.get_schema(1300).name == "INV_GRID_INFO"
    assert client.parser.get_schema(6000).name == "PACK_MAIN_INFO"


def test_client_get_device_state(mock_transport, device_profile):
    """Test getting device state."""
    client = V2Client(transport=mock_transport, profile=device_profile)

    state = client.get_device_state()

    assert "device_id" in state
    assert "model" in state
    assert state["model"] == "EL100V2"


def test_client_get_group_state(mock_transport, device_profile):
    """Test getting group state."""
    client = V2Client(transport=mock_transport, profile=device_profile)

    grid_state = client.get_group_state(BlockGroup.GRID)

    assert "frequency" in grid_state
    assert "voltage" in grid_state


def test_client_manual_connect_disconnect(mock_transport, device_profile):
    """Test manual connect and disconnect."""
    client = V2Client(transport=mock_transport, profile=device_profile)

    client.connect()
    client.disconnect()

    # Should connect and disconnect
    mock_transport.connect.assert_called_once()
    mock_transport.disconnect.assert_called_once()


def _make_parsed_block(block_id: int) -> ParsedBlock:
    return ParsedBlock(
        block_id=block_id,
        name=f"BLOCK_{block_id}",
        values={"ok": True},
        raw=b"",
        length=0,
        protocol_version=2000,
        schema_version="1.0.0",
        timestamp=0.0,
    )


def test_read_group_ex_partial_collects_errors(mock_transport, device_profile):
    """read_group_ex should return both parsed blocks and errors when partial_ok=True."""
    client = V2Client(transport=mock_transport, profile=device_profile)
    client.read_block = Mock(
        side_effect=[
            _make_parsed_block(1100),
            TransportError("boom"),
            _make_parsed_block(1500),
        ]
    )

    result = client.read_group_ex(BlockGroup.INVERTER, partial_ok=True)

    assert len(result.blocks) == 2
    assert len(result.errors) == 1
    assert result.success is False
    assert result.partial is True
    assert result.errors[0][0] == 1400


def test_read_group_ex_fail_fast_raises(mock_transport, device_profile):
    """read_group_ex should fail fast when partial_ok=False."""
    client = V2Client(transport=mock_transport, profile=device_profile)
    client.read_block = Mock(side_effect=TransportError("boom"))

    with pytest.raises(TransportError, match="boom"):
        client.read_group_ex(BlockGroup.INVERTER, partial_ok=False)


def test_read_group_partial_ok_by_default(mock_transport, device_profile):
    """read_group should return partial results by default (partial_ok=True)."""
    client = V2Client(transport=mock_transport, profile=device_profile)
    client.read_block = Mock(
        side_effect=[
            _make_parsed_block(1100),
            TransportError("boom"),
            _make_parsed_block(1500),
        ]
    )

    # With default partial_ok=True, should return partial results
    blocks = client.read_group(BlockGroup.INVERTER)
    assert len(blocks) == 2  # Got 2 out of 3 blocks


def test_read_group_fail_fast_explicit(mock_transport, device_profile):
    """read_group should fail fast when partial_ok=False."""
    client = V2Client(transport=mock_transport, profile=device_profile)
    client.read_block = Mock(
        side_effect=[
            _make_parsed_block(1100),
            TransportError("boom"),
            _make_parsed_block(1500),
        ]
    )

    with pytest.raises(TransportError, match="boom"):
        client.read_group(BlockGroup.INVERTER, partial_ok=False)


def test_dependency_injection_custom_parser(mock_transport, device_profile):
    """Test that custom parser can be injected."""
    mock_parser = Mock()
    mock_parser.get_schema = Mock(return_value=None)

    client = V2Client(
        transport=mock_transport,
        profile=device_profile,
        parser=mock_parser
    )

    assert client.parser is mock_parser


def test_dependency_injection_custom_device(mock_transport, device_profile):
    """Test that custom device model can be injected."""
    mock_device = Mock()

    client = V2Client(
        transport=mock_transport,
        profile=device_profile,
        device=mock_device
    )

    assert client.device is mock_device


def test_dependency_injection_both_custom(mock_transport, device_profile):
    """Test that both parser and device can be injected together."""
    mock_parser = Mock()
    mock_parser.get_schema = Mock(return_value=None)
    mock_device = Mock()

    client = V2Client(
        transport=mock_transport,
        profile=device_profile,
        parser=mock_parser,
        device=mock_device
    )

    assert client.parser is mock_parser
    assert client.device is mock_device


def test_default_dependencies_created_when_not_injected(mock_transport, device_profile):
    """Test that default parser and device are created when not provided."""
    from bluetti_sdk.protocol.v2.parser import V2Parser
    from bluetti_sdk.models.device import V2Device

    client = V2Client(
        transport=mock_transport,
        profile=device_profile
    )

    # Should create default implementations
    assert isinstance(client.parser, V2Parser)
    assert isinstance(client.device, V2Device)


def test_client_uses_instance_scoped_registry(mock_transport, device_profile):
    """Each client can use its own schema registry instance."""
    reg1 = SchemaRegistry()
    reg2 = SchemaRegistry()

    client1 = V2Client(
        transport=mock_transport,
        profile=device_profile,
        schema_registry=reg1,
    )
    client2 = V2Client(
        transport=mock_transport,
        profile=device_profile,
        schema_registry=reg2,
    )

    assert client1.schema_registry is reg1
    assert client2.schema_registry is reg2


def test_schema_conflict_detection():
    """Registry should reject conflicting schemas for same block_id."""
    registry = SchemaRegistry()
    schema1 = BlockSchema(
        block_id=9999,
        name="SCHEMA_A",
        description="A",
        min_length=2,
        fields=[Field(name="f", offset=0, type=UInt16())],
    )
    schema2 = BlockSchema(
        block_id=9999,
        name="SCHEMA_B",
        description="B",
        min_length=2,
        fields=[Field(name="f", offset=0, type=UInt16())],
    )

    registry.register(schema1)
    with pytest.raises(ValueError, match="already registered"):
        registry.register(schema2)


def test_client_schema_isolation_custom_registry(mock_transport, device_profile):
    """Different client registries should remain isolated for custom schemas."""
    reg1 = SchemaRegistry()
    reg2 = SchemaRegistry()
    custom = BlockSchema(
        block_id=9998,
        name="CUSTOM_ONLY_REG1",
        description="custom",
        min_length=2,
        fields=[Field(name="x", offset=0, type=UInt16())],
    )

    reg1.register(custom)
    assert reg1.get(9998) is not None
    assert reg2.get(9998) is None
=== КОНЕЦ ФАЙЛА: tests/unit/test_client.py ===

=== НАЧАЛО ФАЙЛА: tests/unit/test_client_async.py ===
"""Unit tests for AsyncV2Client facade."""

from unittest.mock import Mock

import pytest

from bluetti_sdk.client_async import AsyncV2Client
from bluetti_sdk.devices.profiles import get_device_profile
from bluetti_sdk.errors import TransportError
from bluetti_sdk.models.types import BlockGroup
from bluetti_sdk.protocol.v2.types import ParsedBlock


@pytest.fixture
def mock_transport():
    transport = Mock()
    transport.connect = Mock()
    transport.disconnect = Mock()
    transport.is_connected = Mock(return_value=True)
    return transport


@pytest.fixture
def device_profile():
    return get_device_profile("EL100V2")


def _make_parsed_block(block_id: int) -> ParsedBlock:
    return ParsedBlock(
        block_id=block_id,
        name=f"BLOCK_{block_id}",
        values={"ok": True},
        raw=b"",
        length=0,
        protocol_version=2000,
        schema_version="1.0.0",
        timestamp=0.0,
    )


@pytest.mark.asyncio
async def test_async_connect_disconnect(mock_transport, device_profile):
    client = AsyncV2Client(mock_transport, device_profile)
    await client.connect()
    await client.disconnect()
    mock_transport.connect.assert_called_once()
    mock_transport.disconnect.assert_called_once()


@pytest.mark.asyncio
async def test_async_context_manager(mock_transport, device_profile):
    async with AsyncV2Client(mock_transport, device_profile) as client:
        assert client is not None

    mock_transport.connect.assert_called_once()
    mock_transport.disconnect.assert_called_once()


@pytest.mark.asyncio
async def test_async_read_block_delegates(mock_transport, device_profile):
    client = AsyncV2Client(mock_transport, device_profile)
    parsed = _make_parsed_block(100)
    client._sync_client.read_block = Mock(return_value=parsed)

    result = await client.read_block(100)
    assert result == parsed
    client._sync_client.read_block.assert_called_once_with(100, None)


@pytest.mark.asyncio
async def test_async_read_group_ex_delegates(mock_transport, device_profile):
    client = AsyncV2Client(mock_transport, device_profile)
    client._sync_client.read_group_ex = Mock(return_value=Mock(success=True))
    result = await client.read_group_ex(BlockGroup.CORE, partial_ok=True)
    assert result.success is True
    client._sync_client.read_group_ex.assert_called_once_with(
        BlockGroup.CORE, True
    )


@pytest.mark.asyncio
async def test_async_propagates_exceptions(mock_transport, device_profile):
    client = AsyncV2Client(mock_transport, device_profile)
    client._sync_client.read_block = Mock(side_effect=TransportError("boom"))

    with pytest.raises(TransportError, match="boom"):
        await client.read_block(100)
=== КОНЕЦ ФАЙЛА: tests/unit/test_client_async.py ===

=== НАЧАЛО ФАЙЛА: tests/unit/test_declarative_block_100.py ===
"""Test declarative Block 100 definition."""

import pytest


def _get_type_fingerprint(field_type) -> str:
    """Get type fingerprint including parameters.

    This ensures we catch differences like String(length=8) vs String(length=12).
    Similar to SchemaRegistry._get_type_fingerprint().
    """
    type_name = type(field_type).__name__
    params = []

    if hasattr(field_type, "length"):
        params.append(f"length={field_type.length}")

    if hasattr(field_type, "bits"):
        params.append(f"bits={field_type.bits}")

    if hasattr(field_type, "mapping") and field_type.mapping is not None:
        mapping_items = sorted(field_type.mapping.items())
        mapping_repr = repr(tuple(mapping_items))
        params.append(f"mapping={mapping_repr}")

    return f"{type_name}({', '.join(params)})" if params else type_name


def test_block_100_declarative_schema_generation():
    """Test that AppHomeDataBlock generates valid BlockSchema."""
    from bluetti_sdk.schemas.block_100_declarative import (
        BLOCK_100_DECLARATIVE_SCHEMA,
        AppHomeDataBlock,
    )

    schema = AppHomeDataBlock.to_schema()

    # Check basic properties
    assert schema.block_id == 100
    assert schema.name == "APP_HOME_DATA"
    assert schema.min_length == 120
    assert schema.protocol_version == 2000
    assert schema.strict is False

    # Check has fields
    assert len(schema.fields) > 0

    # Check specific critical fields exist
    field_names = {f.name for f in schema.fields}
    assert "pack_voltage" in field_names
    assert "soc" in field_names
    assert "device_model" in field_names
    assert "pv_power" in field_names


def test_block_100_declarative_vs_imperative():
    """Test declarative and imperative Block 100 schemas are equivalent."""
    from bluetti_sdk.schemas.block_100 import BLOCK_100_SCHEMA
    from bluetti_sdk.schemas.block_100_declarative import (
        BLOCK_100_DECLARATIVE_SCHEMA,
    )

    # Both schemas should have same basic properties
    assert BLOCK_100_SCHEMA.block_id == BLOCK_100_DECLARATIVE_SCHEMA.block_id
    assert BLOCK_100_SCHEMA.name == BLOCK_100_DECLARATIVE_SCHEMA.name
    assert BLOCK_100_SCHEMA.min_length == BLOCK_100_DECLARATIVE_SCHEMA.min_length
    assert BLOCK_100_SCHEMA.strict == BLOCK_100_DECLARATIVE_SCHEMA.strict

    # Both should have same number of fields
    assert len(BLOCK_100_SCHEMA.fields) == len(
        BLOCK_100_DECLARATIVE_SCHEMA.fields
    )

    # Build field maps for comparison
    imperative_fields = {f.name: f for f in BLOCK_100_SCHEMA.fields}
    declarative_fields = {
        f.name: f for f in BLOCK_100_DECLARATIVE_SCHEMA.fields
    }

    # Check all field names match
    assert set(imperative_fields.keys()) == set(declarative_fields.keys())

    # Check key field properties match
    for name in imperative_fields.keys():
        imp_field = imperative_fields[name]
        dec_field = declarative_fields[name]

        # Check offsets match
        assert imp_field.offset == dec_field.offset, (
            f"Field '{name}': offset mismatch"
        )

        # Check types match (fingerprint comparison includes parameters)
        imp_fingerprint = _get_type_fingerprint(imp_field.type)
        dec_fingerprint = _get_type_fingerprint(dec_field.type)
        assert imp_fingerprint == dec_fingerprint, (
            f"Field '{name}': type mismatch - "
            f"imperative={imp_fingerprint}, declarative={dec_fingerprint}"
        )

        # Check units match
        assert imp_field.unit == dec_field.unit, f"Field '{name}': unit mismatch"

        # Check transforms match (both should be tuples or None)
        if imp_field.transform or dec_field.transform:
            imp_xform = tuple(imp_field.transform) if imp_field.transform else None
            dec_xform = tuple(dec_field.transform) if dec_field.transform else None
            assert imp_xform == dec_xform, (
                f"Field '{name}': transform mismatch"
            )


def test_block_100_declarative_field_details():
    """Test specific field details in declarative Block 100."""
    from bluetti_sdk.schemas.block_100_declarative import AppHomeDataBlock

    schema = AppHomeDataBlock.to_schema()
    fields_by_name = {f.name: f for f in schema.fields}

    # Test pack_voltage
    pack_voltage = fields_by_name["pack_voltage"]
    assert pack_voltage.offset == 0
    assert pack_voltage.unit == "V"
    assert pack_voltage.transform == ("scale:0.1",)
    assert pack_voltage.required is True

    # Test soc
    soc = fields_by_name["soc"]
    assert soc.offset == 4
    assert soc.unit == "%"
    assert soc.required is True

    # Test grid_power (signed int32)
    grid_power = fields_by_name["grid_power"]
    assert grid_power.offset == 92
    assert grid_power.unit == "W"
    assert grid_power.min_protocol_version == 2001
    from bluetti_sdk.protocol.v2.datatypes import Int32
    assert isinstance(grid_power.type, Int32)

    # Test device_model (string)
    device_model = fields_by_name["device_model"]
    assert device_model.offset == 20
    from bluetti_sdk.protocol.v2.datatypes import String
    assert isinstance(device_model.type, String)
    assert device_model.type.length == 12


def test_block_100_declarative_immutability():
    """Test that declarative Block 100 schema is immutable."""
    from bluetti_sdk.schemas.block_100_declarative import AppHomeDataBlock
    import dataclasses

    schema = AppHomeDataBlock.to_schema()

    # Schema should be frozen
    with pytest.raises(dataclasses.FrozenInstanceError):
        schema.name = "HACKED"

    # Fields should be immutable tuples
    with pytest.raises(AttributeError):
        schema.fields.append(None)  # tuple has no append
=== КОНЕЦ ФАЙЛА: tests/unit/test_declarative_block_100.py ===

=== НАЧАЛО ФАЙЛА: tests/unit/test_declarative_schema.py ===
"""Unit tests for declarative block schema system."""

import pytest
from bluetti_sdk.protocol.v2.datatypes import Int32, String, UInt16, UInt32
from bluetti_sdk.protocol.v2.schema import BlockSchema
from bluetti_sdk.schemas.declarative import block_field, block_schema
from dataclasses import dataclass


def test_block_field_metadata():
    """Test block_field creates proper field metadata."""
    from bluetti_sdk.schemas.declarative import BlockFieldMetadata

    @dataclass
    class TestBlock:
        voltage: float = block_field(
            offset=0,
            type=UInt16(),
            transform=["scale:0.1"],
            unit="V",
            description="Test voltage"
        )

    # Get field metadata
    from dataclasses import fields
    field_def = fields(TestBlock)[0]
    metadata = field_def.metadata.get('block_field')

    assert isinstance(metadata, BlockFieldMetadata)
    assert metadata.offset == 0
    assert isinstance(metadata.type, UInt16)
    assert metadata.transform == ("scale:0.1",)  # Converted to tuple
    assert metadata.unit == "V"
    assert metadata.description == "Test voltage"


def test_block_schema_decorator():
    """Test @block_schema decorator generates BlockSchema."""

    @block_schema(block_id=9001, name="TEST_BLOCK")
    @dataclass
    class TestBlock:
        """Test block description."""

        field1: int = block_field(offset=0, type=UInt16())
        field2: int = block_field(offset=2, type=UInt16())

    # Check schema attached to class
    assert hasattr(TestBlock, '_block_schema')
    assert hasattr(TestBlock, 'to_schema')

    # Get generated schema
    schema = TestBlock.to_schema()

    assert isinstance(schema, BlockSchema)
    assert schema.block_id == 9001
    assert schema.name == "TEST_BLOCK"
    assert schema.description == "Test block description."
    assert len(schema.fields) == 2
    assert schema.fields[0].name == "field1"
    assert schema.fields[1].name == "field2"


def test_auto_min_length_calculation():
    """Test automatic min_length calculation from field offsets."""

    @block_schema(block_id=9002, name="AUTO_LENGTH")
    @dataclass
    class AutoLengthBlock:
        """Auto length test."""

        field1: int = block_field(offset=0, type=UInt16())  # 0-1
        field2: int = block_field(offset=2, type=UInt32())  # 2-5
        field3: str = block_field(offset=10, type=String(length=8))  # 10-17

    schema = AutoLengthBlock.to_schema()

    # min_length should be max(field_end) = 10 + 8 = 18
    assert schema.min_length == 18


def test_explicit_min_length():
    """Test explicit min_length overrides auto-calculation."""

    @block_schema(block_id=9003, name="EXPLICIT_LENGTH", min_length=100)
    @dataclass
    class ExplicitLengthBlock:
        """Explicit length test."""

        field1: int = block_field(offset=0, type=UInt16())

    schema = ExplicitLengthBlock.to_schema()
    assert schema.min_length == 100  # Explicit, not auto-calculated


def test_field_types_and_transforms():
    """Test various field types and transforms are preserved."""

    @block_schema(block_id=9004, name="FIELD_TYPES")
    @dataclass
    class FieldTypesBlock:
        """Field types test."""

        uint16_field: int = block_field(offset=0, type=UInt16())
        uint32_field: int = block_field(offset=2, type=UInt32())
        int32_field: int = block_field(offset=6, type=Int32())
        string_field: str = block_field(offset=10, type=String(length=8))

        scaled_field: float = block_field(
            offset=20,
            type=UInt16(),
            transform=["scale:0.1", "minus:40"],
            unit="°C"
        )

    schema = FieldTypesBlock.to_schema()

    # Check field types
    assert isinstance(schema.fields[0].type, UInt16)
    assert isinstance(schema.fields[1].type, UInt32)
    assert isinstance(schema.fields[2].type, Int32)
    assert isinstance(schema.fields[3].type, String)

    # Check transforms
    scaled = schema.fields[4]
    assert scaled.transform == ("scale:0.1", "minus:40")
    assert scaled.unit == "°C"


def test_optional_and_protocol_version():
    """Test optional fields and protocol version requirements."""

    @block_schema(block_id=9005, name="OPTIONAL_FIELDS")
    @dataclass
    class OptionalFieldsBlock:
        """Optional fields test."""

        required_field: int = block_field(
            offset=0,
            type=UInt16(),
            required=True
        )

        optional_field: int = block_field(
            offset=2,
            type=UInt16(),
            required=False
        )

        v2001_field: int = block_field(
            offset=4,
            type=UInt32(),
            min_protocol_version=2001
        )

    schema = OptionalFieldsBlock.to_schema()

    assert schema.fields[0].required is True
    assert schema.fields[1].required is False
    assert schema.fields[2].min_protocol_version == 2001


def test_schema_immutability():
    """Test that generated schema is immutable (frozen)."""

    @block_schema(block_id=9006, name="IMMUTABLE_TEST")
    @dataclass
    class ImmutableBlock:
        """Immutable test."""

        field1: int = block_field(offset=0, type=UInt16())

    schema = ImmutableBlock.to_schema()

    # Should be frozen
    import dataclasses
    with pytest.raises(dataclasses.FrozenInstanceError):
        schema.name = "HACKED"

    with pytest.raises(dataclasses.FrozenInstanceError):
        schema.fields[0].offset = 999


def test_multiple_blocks_independent():
    """Test multiple declarative blocks are independent."""

    @block_schema(block_id=9007, name="BLOCK_A")
    @dataclass
    class BlockA:
        """Block A."""
        field_a: int = block_field(offset=0, type=UInt16())

    @block_schema(block_id=9008, name="BLOCK_B")
    @dataclass
    class BlockB:
        """Block B."""
        field_b: int = block_field(offset=0, type=UInt32())

    schema_a = BlockA.to_schema()
    schema_b = BlockB.to_schema()

    assert schema_a.block_id == 9007
    assert schema_b.block_id == 9008
    assert schema_a.fields[0].name == "field_a"
    assert schema_b.fields[0].name == "field_b"


def test_non_block_fields_ignored():
    """Test that non-block fields are ignored during schema generation."""

    @block_schema(block_id=9009, name="MIXED_FIELDS")
    @dataclass
    class MixedFieldsBlock:
        """Mixed fields test."""

        # Block field
        block_field1: int = block_field(offset=0, type=UInt16())

        # Regular dataclass field (not a block field)
        runtime_value: int = 0

        # Block field
        block_field2: int = block_field(offset=2, type=UInt16())

    schema = MixedFieldsBlock.to_schema()

    # Should only have 2 fields (block fields), runtime_value ignored
    assert len(schema.fields) == 2
    assert schema.fields[0].name == "block_field1"
    assert schema.fields[1].name == "block_field2"


def test_block_schema_requires_dataclass():
    """Test that @block_schema raises clear error if @dataclass is missing."""

    with pytest.raises(TypeError) as exc_info:
        @block_schema(block_id=9010, name="NOT_DATACLASS")
        class NotDataclassBlock:
            """Missing @dataclass decorator."""
            field1: int = block_field(offset=0, type=UInt16())

    # Check error message is helpful
    error_msg = str(exc_info.value)
    assert "@block_schema can only be applied to dataclasses" in error_msg
    assert "Add @dataclass decorator" in error_msg
    assert "NotDataclassBlock" in error_msg
=== КОНЕЦ ФАЙЛА: tests/unit/test_declarative_schema.py ===

=== НАЧАЛО ФАЙЛА: tests/unit/test_schema_registry.py ===
"""Unit tests for Schema Registry."""

import dataclasses

import pytest
from bluetti_sdk.protocol.v2.datatypes import UInt16
from bluetti_sdk.protocol.v2.schema import BlockSchema, Field
from bluetti_sdk.schemas import registry


@pytest.fixture
def clean_registry():
    """Clear registry before and after test.

    Use this fixture explicitly in tests that need a clean registry.
    """
    registry._clear_for_testing()
    yield
    registry._clear_for_testing()


@pytest.fixture
def test_schema_1():
    """Create test schema 1."""
    return BlockSchema(
        block_id=9001,
        name="TEST_BLOCK_1",
        description="Test block 1",
        min_length=4,
        fields=[
            Field(name="field1", offset=0, type=UInt16()),
        ],
    )


@pytest.fixture
def test_schema_2():
    """Create test schema 2."""
    return BlockSchema(
        block_id=9002,
        name="TEST_BLOCK_2",
        description="Test block 2",
        min_length=4,
        fields=[
            Field(name="field2", offset=0, type=UInt16()),
        ],
    )


def test_register_schema(clean_registry, test_schema_1):
    """Test registering a single schema."""
    registry.register(test_schema_1)

    # Should be retrievable
    retrieved = registry.get(9001)
    assert retrieved is not None
    assert retrieved.name == "TEST_BLOCK_1"


def test_register_duplicate_schema(clean_registry, test_schema_1):
    """Test registering the same schema twice."""
    registry.register(test_schema_1)

    # Second registration should be silently skipped
    registry.register(test_schema_1)

    # Should still have only one
    assert len(registry.list_blocks()) == 1


def test_register_conflicting_schema(clean_registry, test_schema_1):
    """Test registering different schema with same block_id (different name)."""
    registry.register(test_schema_1)

    # Different schema with same block_id but different name
    conflicting = BlockSchema(
        block_id=9001,
        name="DIFFERENT_NAME",
        description="Different",
        min_length=4,
        fields=[],
    )

    # Should raise error
    with pytest.raises(ValueError, match="already registered"):
        registry.register(conflicting)


def test_register_conflicting_structure(clean_registry, test_schema_1):
    """Test registering schema with same block_id and name but different fields."""
    registry.register(test_schema_1)

    # Same block_id and name, but different fields
    conflicting = BlockSchema(
        block_id=9001,
        name="TEST_BLOCK_1",  # Same name
        description="Different structure",
        min_length=4,
        fields=[
            Field(name="different_field", offset=0, type=UInt16()),
        ],
    )

    # Should raise error about structure conflict
    with pytest.raises(ValueError, match="structure conflict"):
        registry.register(conflicting)


def test_register_conflicting_offset(clean_registry):
    """Test detecting offset changes in field."""
    schema1 = BlockSchema(
        block_id=9003,
        name="TEST",
        description="Test",
        min_length=4,
        fields=[
            Field(name="field1", offset=0, type=UInt16()),
        ],
    )
    registry.register(schema1)

    # Same field name, different offset
    schema2 = BlockSchema(
        block_id=9003,
        name="TEST",
        description="Test",
        min_length=4,
        fields=[
            Field(name="field1", offset=2, type=UInt16()),  # Changed offset
        ],
    )

    with pytest.raises(ValueError, match="offset changed"):
        registry.register(schema2)


def test_register_conflicting_type(clean_registry):
    """Test detecting type changes in field."""
    from bluetti_sdk.protocol.v2.datatypes import UInt8

    schema1 = BlockSchema(
        block_id=9004,
        name="TEST",
        description="Test",
        min_length=4,
        fields=[
            Field(name="field1", offset=0, type=UInt16()),
        ],
    )
    registry.register(schema1)

    # Same field name, different type
    schema2 = BlockSchema(
        block_id=9004,
        name="TEST",
        description="Test",
        min_length=4,
        fields=[
            Field(name="field1", offset=0, type=UInt8()),  # Changed type
        ],
    )

    with pytest.raises(ValueError, match="type changed"):
        registry.register(schema2)


def test_register_conflicting_required(clean_registry):
    """Test detecting required flag changes."""
    schema1 = BlockSchema(
        block_id=9005,
        name="TEST",
        description="Test",
        min_length=4,
        fields=[
            Field(name="field1", offset=0, type=UInt16(), required=True),
        ],
    )
    registry.register(schema1)

    # Same field, different required flag
    schema2 = BlockSchema(
        block_id=9005,
        name="TEST",
        description="Test",
        min_length=4,
        fields=[
            Field(name="field1", offset=0, type=UInt16(), required=False),
        ],
    )

    with pytest.raises(ValueError, match="required changed"):
        registry.register(schema2)


def test_register_conflicting_transform(clean_registry):
    """Test detecting transform changes."""
    schema1 = BlockSchema(
        block_id=9006,
        name="TEST",
        description="Test",
        min_length=4,
        fields=[
            Field(name="field1", offset=0, type=UInt16(), transform=["scale:0.1"]),
        ],
    )
    registry.register(schema1)

    # Same field, different transform
    schema2 = BlockSchema(
        block_id=9006,
        name="TEST",
        description="Test",
        min_length=4,
        fields=[
            Field(name="field1", offset=0, type=UInt16(), transform=["scale:0.01"]),
        ],
    )

    with pytest.raises(ValueError, match="transform changed"):
        registry.register(schema2)


def test_register_conflicting_string_length(clean_registry):
    """Test detecting String type parameter changes (length)."""
    from bluetti_sdk.protocol.v2.datatypes import String

    schema1 = BlockSchema(
        block_id=9007,
        name="TEST",
        description="Test",
        min_length=10,
        fields=[
            Field(name="device_model", offset=0, type=String(length=8)),
        ],
    )
    registry.register(schema1)

    # Same field name and type class, but different length
    schema2 = BlockSchema(
        block_id=9007,
        name="TEST",
        description="Test",
        min_length=14,
        fields=[
            Field(name="device_model", offset=0, type=String(length=12)),
        ],
    )

    # Should detect String(length=8) vs String(length=12) as different
    with pytest.raises(ValueError, match="type changed.*String"):
        registry.register(schema2)


def test_register_conflicting_bitmap_bits(clean_registry):
    """Test detecting Bitmap type parameter changes (bits)."""
    from bluetti_sdk.protocol.v2.datatypes import Bitmap

    schema1 = BlockSchema(
        block_id=9008,
        name="TEST",
        description="Test",
        min_length=4,
        fields=[
            Field(name="status", offset=0, type=Bitmap(bits=16)),
        ],
    )
    registry.register(schema1)

    # Same field name and type class, but different bits
    schema2 = BlockSchema(
        block_id=9008,
        name="TEST",
        description="Test",
        min_length=4,
        fields=[
            Field(name="status", offset=0, type=Bitmap(bits=32)),
        ],
    )

    # Should detect Bitmap(bits=16) vs Bitmap(bits=32) as different
    with pytest.raises(ValueError, match="type changed.*Bitmap"):
        registry.register(schema2)


def test_register_conflicting_enum_mapping(clean_registry):
    """Test detecting Enum type mapping changes."""
    from bluetti_sdk.protocol.v2.datatypes import Enum

    # Two enums with same number of values but different mappings
    schema1 = BlockSchema(
        block_id=9009,
        name="TEST",
        description="Test",
        min_length=4,
        fields=[
            Field(
                name="mode",
                offset=0,
                type=Enum(
                    mapping={
                        0: "OFF",
                        1: "ON",
                        2: "AUTO",
                    }
                ),
            ),
        ],
    )
    registry.register(schema1)

    # Same number of values (3), but different mapping
    schema2 = BlockSchema(
        block_id=9009,
        name="TEST",
        description="Test",
        min_length=4,
        fields=[
            Field(
                name="mode",
                offset=0,
                type=Enum(
                    mapping={
                        0: "DISABLED",  # Different name for 0
                        1: "ENABLED",  # Different name for 1
                        2: "STANDBY",  # Different name for 2
                    }
                ),
            ),
        ],
    )

    # Should detect different mapping content, not just size
    with pytest.raises(ValueError, match="type changed.*Enum"):
        registry.register(schema2)


def test_register_many(clean_registry, test_schema_1, test_schema_2):
    """Test registering multiple schemas at once."""
    registry.register_many([test_schema_1, test_schema_2])

    assert len(registry.list_blocks()) == 2
    assert registry.get(9001) is not None
    assert registry.get(9002) is not None


def test_get_nonexistent_schema(clean_registry):
    """Test getting a schema that doesn't exist."""
    result = registry.get(99999)
    assert result is None


def test_list_blocks(clean_registry, test_schema_1, test_schema_2):
    """Test listing registered block IDs."""
    registry.register_many([test_schema_1, test_schema_2])

    blocks = registry.list_blocks()
    assert blocks == [9001, 9002]  # Should be sorted


def test_resolve_blocks_strict(clean_registry, test_schema_1, test_schema_2):
    """Test resolving schemas in strict mode."""
    registry.register_many([test_schema_1, test_schema_2])

    # All schemas available
    resolved = registry.resolve_blocks([9001, 9002], strict=True)
    assert len(resolved) == 2
    assert 9001 in resolved
    assert 9002 in resolved

    # Missing schema should raise error
    with pytest.raises(ValueError, match="Missing schemas"):
        registry.resolve_blocks([9001, 99999], strict=True)


def test_resolve_blocks_lenient(clean_registry, test_schema_1):
    """Test resolving schemas in lenient mode."""
    registry.register(test_schema_1)

    # Should return only found schemas, skip missing
    resolved = registry.resolve_blocks([9001, 99999], strict=False)
    assert len(resolved) == 1
    assert 9001 in resolved
    assert 99999 not in resolved


def test_resolve_empty_list(clean_registry):
    """Test resolving empty block list."""
    resolved = registry.resolve_blocks([], strict=True)
    assert resolved == {}


def test_clear(clean_registry):
    """Test clearing the registry (testing only)."""
    schema = BlockSchema(
        block_id=9001, name="TEST", description="Test", min_length=4, fields=[]
    )
    registry.register(schema)
    assert len(registry.list_blocks()) == 1

    registry._clear_for_testing()
    assert len(registry.list_blocks()) == 0
    assert registry.get(9001) is None


def test_lazy_registration():
    """Test lazy registration via ensure_registered().

    Schemas should NOT be registered on import, only when ensure_registered() is called.
    """
    # Clear registry and reset registration flag
    registry._clear_for_testing()

    import bluetti_sdk.schemas

    bluetti_sdk.schemas._reset_registration_flag()

    # After clearing, schemas should NOT be registered yet
    blocks = registry.list_blocks()
    assert len(blocks) == 0

    # Call ensure_registered to trigger lazy registration
    bluetti_sdk.schemas.ensure_registered()

    # Now schemas should be registered
    blocks = bluetti_sdk.schemas.list_blocks()
    assert 100 in blocks  # BLOCK_100_SCHEMA
    assert 1300 in blocks  # BLOCK_1300_SCHEMA
    assert 6000 in blocks  # BLOCK_6000_SCHEMA

    # Verify they're retrievable
    assert bluetti_sdk.schemas.get(100).name == "APP_HOME_DATA"
    assert bluetti_sdk.schemas.get(1300).name == "INV_GRID_INFO"
    assert bluetti_sdk.schemas.get(6000).name == "PACK_MAIN_INFO"

    # Calling ensure_registered() again should be idempotent
    bluetti_sdk.schemas.ensure_registered()
    assert len(bluetti_sdk.schemas.list_blocks()) == 3  # Still 3 schemas


def test_schema_immutability(clean_registry):
    """Test that BlockSchema and Field are immutable (frozen).

    This prevents post-registration mutations that would break wire-format safety.
    """
    schema = BlockSchema(
        block_id=9010,
        name="TEST_IMMUTABLE",
        description="Test immutability",
        min_length=4,
        fields=[
            Field(name="field1", offset=0, type=UInt16()),
        ],
    )

    # Register schema
    registry.register(schema)

    # Attempt to modify BlockSchema - should raise FrozenInstanceError
    with pytest.raises(dataclasses.FrozenInstanceError):
        schema.name = "MODIFIED"

    # Attempt to modify Field - should raise FrozenInstanceError
    field = schema.fields[0]
    with pytest.raises(dataclasses.FrozenInstanceError):
        field.offset = 999

    # Verify schema in registry is still intact
    retrieved = registry.get(9010)
    assert retrieved.name == "TEST_IMMUTABLE"
    assert retrieved.fields[0].offset == 0


def test_datatype_immutability(clean_registry):
    """Test that DataType objects (String, Bitmap, Enum) are immutable.

    This ensures wire-format safety even if types are modified after registration.
    """
    from bluetti_sdk.protocol.v2.datatypes import Bitmap, Enum, String

    # Test String immutability
    string_type = String(length=8)
    with pytest.raises(dataclasses.FrozenInstanceError):
        string_type.length = 16

    # Test Bitmap immutability
    bitmap_type = Bitmap(bits=16)
    with pytest.raises(dataclasses.FrozenInstanceError):
        bitmap_type.bits = 32

    # Test Enum immutability
    enum_type = Enum(mapping={0: "OFF", 1: "ON"})
    with pytest.raises(dataclasses.FrozenInstanceError):
        enum_type.mapping = {0: "DISABLED", 1: "ENABLED"}

    # Test that Enum mapping is truly immutable (MappingProxyType)
    with pytest.raises(TypeError):  # MappingProxyType raises TypeError on mutation
        enum_type.mapping[2] = "AUTO"

    # Verify in a registered schema context
    schema = BlockSchema(
        block_id=9011,
        name="TEST_DATATYPE_IMMUTABLE",
        description="Test DataType immutability",
        min_length=10,
        fields=[
            Field(name="device_model", offset=0, type=string_type),
            Field(name="status", offset=8, type=bitmap_type),
        ],
    )

    registry.register(schema)

    # Retrieved schema should have the same immutable types
    retrieved = registry.get(9011)
    assert retrieved.fields[0].type.length == 8
    assert retrieved.fields[1].type.bits == 16

    # Attempt to modify types after registration - should still fail
    with pytest.raises(dataclasses.FrozenInstanceError):
        retrieved.fields[0].type.length = 999


def test_enum_base_type_immutability():
    """Test that Enum validates base_type is immutable (strict contract).

    This prevents architectural bypass via mutable custom DataType subclasses.
    Enforces strict whitelist: only SDK built-in types or frozen dataclasses.
    """
    from dataclasses import dataclass
    from typing import Any

    from bluetti_sdk.protocol.v2.datatypes import (
        DataType,
        Enum,
        Int8,
        UInt8,
        UInt16,
    )

    # 1. SDK built-in immutable types should work
    Enum(mapping={0: "OFF"}, base_type=UInt8())  # OK - whitelist
    Enum(mapping={0: "OFF"}, base_type=UInt16())  # OK - whitelist
    Enum(mapping={0: "OFF"}, base_type=Int8())  # OK - whitelist

    # 2. Frozen custom dataclass should work
    @dataclass(frozen=True)
    class FrozenCustomType(DataType):
        def parse(self, data: bytes, offset: int) -> Any:
            return 0

        def size(self) -> int:
            return 1

        def encode(self, value: Any) -> bytes:
            return b"\x00"

    Enum(mapping={0: "X"}, base_type=FrozenCustomType())  # OK - frozen dataclass

    # 3. Mutable dataclass should be rejected
    @dataclass  # NOT frozen
    class MutableDataclassType(DataType):
        value: int = 0

        def parse(self, data: bytes, offset: int) -> Any:
            return 0

        def size(self) -> int:
            return 1

        def encode(self, value: Any) -> bytes:
            return b"\x00"

    with pytest.raises(ValueError, match="must be immutable.*MutableDataclassType"):
        Enum(mapping={0: "X"}, base_type=MutableDataclassType())

    # 4. Non-dataclass mutable class should be rejected (edge case)
    class MutableNonDataclass(DataType):
        def __init__(self):
            self.value = 0  # mutable state

        def parse(self, data: bytes, offset: int) -> Any:
            return 0

        def size(self) -> int:
            return 1

        def encode(self, value: Any) -> bytes:
            return b"\x00"

    with pytest.raises(ValueError, match="must be immutable.*MutableNonDataclass"):
        Enum(mapping={0: "X"}, base_type=MutableNonDataclass())


def test_enum_defensive_copy(clean_registry):
    """Test that Enum makes defensive copy of mapping to prevent external mutation.

    This ensures that mutating the original dict after Enum creation does not
    affect the Enum's internal mapping (defensive copy protection).
    """
    from types import MappingProxyType

    from bluetti_sdk.protocol.v2.datatypes import Enum

    # Test 1: Defensive copy from regular dict
    original_mapping = {0: "OFF", 1: "ON", 2: "AUTO"}
    enum_type = Enum(mapping=original_mapping)

    # Verify initial state
    assert enum_type.mapping[0] == "OFF"
    assert enum_type.mapping[1] == "ON"
    assert enum_type.mapping[2] == "AUTO"

    # Mutate the ORIGINAL dict (external reference)
    original_mapping[0] = "DISABLED"
    original_mapping[3] = "MANUAL"
    del original_mapping[2]

    # Enum's mapping should be UNCHANGED (defensive copy)
    assert enum_type.mapping[0] == "OFF"  # not "DISABLED"
    assert enum_type.mapping[1] == "ON"
    assert enum_type.mapping[2] == "AUTO"  # not deleted
    assert 3 not in enum_type.mapping  # "MANUAL" not added

    # Test 2: Defensive copy from MappingProxyType wrapping mutable dict
    # This is the edge case: if someone passes MappingProxyType(mutable_dict),
    # we still need to make a defensive copy
    external_dict = {0: "ENABLED", 1: "DISABLED"}
    proxy = MappingProxyType(external_dict)
    enum_from_proxy = Enum(mapping=proxy)

    # Verify initial state
    assert enum_from_proxy.mapping[0] == "ENABLED"
    assert enum_from_proxy.mapping[1] == "DISABLED"

    # Mutate the UNDERLYING dict (external reference)
    external_dict[0] = "HACKED"
    external_dict[2] = "INJECTED"

    # Enum's mapping should be UNCHANGED (defensive copy even from MappingProxyType)
    assert enum_from_proxy.mapping[0] == "ENABLED"  # not "HACKED"
    assert enum_from_proxy.mapping[1] == "DISABLED"
    assert 2 not in enum_from_proxy.mapping  # "INJECTED" not added

    # Test in registered schema context
    schema = BlockSchema(
        block_id=9012,
        name="TEST_ENUM_DEFENSIVE_COPY",
        description="Test Enum defensive copy",
        min_length=4,
        fields=[
            Field(name="mode", offset=0, type=enum_type),
        ],
    )

    registry.register(schema)

    # Retrieved Enum should still have original values
    retrieved_enum = registry.get(9012).fields[0].type
    assert retrieved_enum.mapping[0] == "OFF"
    assert retrieved_enum.mapping[2] == "AUTO"
    assert 3 not in retrieved_enum.mapping
=== КОНЕЦ ФАЙЛА: tests/unit/test_schema_registry.py ===

=== НАЧАЛО ФАЙЛА: tests/unit/transport/test_mqtt_mock.py ===
"""Mock-based unit tests for MQTT transport layer.

These tests use mocks to test MQTT transport without real broker connection.
Covers thread-safety, timeout handling, and response validation.
"""

from unittest.mock import MagicMock, Mock, patch

import pytest
from bluetti_sdk.errors import TransportError
from bluetti_sdk.protocol.modbus import build_modbus_request
from bluetti_sdk.transport.mqtt import MQTTConfig, MQTTTransport


def build_test_response(data: bytes) -> bytes:
    """Build valid Modbus response frame with CRC.

    Args:
        data: Raw data bytes (without framing)

    Returns:
        Complete Modbus frame with valid CRC
    """
    # Build frame: [addr][func][count][data...][crc]
    device_addr = 0x01
    function_code = 0x03
    byte_count = len(data)

    frame = bytes([device_addr, function_code, byte_count]) + data

    # Calculate CRC16-Modbus
    crc = 0xFFFF
    for byte in frame:
        crc ^= byte
        for _ in range(8):
            if crc & 0x0001:
                crc = (crc >> 1) ^ 0xA001
            else:
                crc >>= 1

    # Append CRC (little-endian)
    frame_with_crc = frame + bytes([crc & 0xFF, (crc >> 8) & 0xFF])

    return frame_with_crc


@pytest.fixture
def mqtt_config():
    """Create test MQTT config without real certificates."""
    return MQTTConfig(broker="test.broker.com", port=18760, device_sn="TEST_DEVICE_001")


@pytest.fixture
def mock_mqtt_client():
    """Create mock paho MQTT client."""
    mock_client = MagicMock()

    # Mock successful operations
    mock_client.connect.return_value = 0
    mock_client.subscribe.return_value = (0, 1)
    mock_client.publish.return_value = MagicMock(wait_for_publish=MagicMock())
    mock_client.loop_start.return_value = None
    mock_client.loop_stop.return_value = None
    mock_client.disconnect.return_value = None

    return mock_client


class TestMQTTConfig:
    """Test MQTTConfig dataclass."""

    def test_config_defaults(self):
        """Test default values."""
        config = MQTTConfig(device_sn="TEST")

        assert config.broker == "iot.bluettipower.com"
        assert config.port == 18760
        assert config.device_sn == "TEST"
        assert config.pfx_cert is None
        assert config.cert_password is None
        assert config.keepalive == 60

    def test_config_custom_values(self):
        """Test custom configuration."""
        config = MQTTConfig(
            broker="custom.broker.com",
            port=8883,
            device_sn="CUSTOM_DEVICE",
            keepalive=120,
        )

        assert config.broker == "custom.broker.com"
        assert config.port == 8883
        assert config.device_sn == "CUSTOM_DEVICE"
        assert config.keepalive == 120


class TestMQTTTransportCreation:
    """Test MQTT transport initialization."""

    @patch("bluetti_sdk.transport.mqtt.mqtt.Client")
    def test_transport_creation(self, mock_client_class, mqtt_config):
        """Test creating transport."""
        transport = MQTTTransport(mqtt_config)

        assert transport.config == mqtt_config
        assert not transport._connected
        assert transport._waiting is False
        assert transport._subscribe_topic == "PUB/TEST_DEVICE_001"
        assert transport._publish_topic == "SUB/TEST_DEVICE_001"

    @patch("bluetti_sdk.transport.mqtt.mqtt.Client")
    def test_topics_generation(self, mock_client_class, mqtt_config):
        """Test topic name generation."""
        transport = MQTTTransport(mqtt_config)

        # From client perspective:
        # - Subscribe to device's publish topic (PUB/{sn})
        # - Publish to device's subscribe topic (SUB/{sn})
        assert transport._subscribe_topic == "PUB/TEST_DEVICE_001"
        assert transport._publish_topic == "SUB/TEST_DEVICE_001"


class TestMQTTConnection:
    """Test MQTT connection lifecycle."""

    @patch("bluetti_sdk.transport.mqtt.mqtt.Client")
    def test_connect_success(self, mock_client_class, mqtt_config, mock_mqtt_client):
        """Test successful connection."""
        mock_client_class.return_value = mock_mqtt_client

        transport = MQTTTransport(mqtt_config)

        # Mock successful connection via callback
        def trigger_on_connect(*args, **kwargs):
            # Simulate connection callback
            transport._on_connect(mock_mqtt_client, None, None, 0)

        mock_mqtt_client.connect.side_effect = trigger_on_connect

        transport.connect()

        # Verify connection sequence (keyword argument)
        mock_mqtt_client.connect.assert_called_once_with(
            "test.broker.com", 18760, keepalive=60
        )
        mock_mqtt_client.loop_start.assert_called_once()
        assert transport.is_connected()

    @patch("bluetti_sdk.transport.mqtt.mqtt.Client")
    def test_connect_failure(self, mock_client_class, mqtt_config, mock_mqtt_client):
        """Test connection failure."""
        mock_client_class.return_value = mock_mqtt_client
        mock_mqtt_client.connect.side_effect = Exception("Connection refused")

        transport = MQTTTransport(mqtt_config)

        with pytest.raises(TransportError, match="Failed to connect"):
            transport.connect()

        assert not transport.is_connected()

    @patch("bluetti_sdk.transport.mqtt.mqtt.Client")
    def test_connect_failure_rc(self, mock_client_class, mqtt_config, mock_mqtt_client):
        """Test broker connection reject (rc != 0) fails fast with rc."""
        mock_client_class.return_value = mock_mqtt_client

        transport = MQTTTransport(mqtt_config)

        def trigger_on_connect_fail(*args, **kwargs):
            transport._on_connect(mock_mqtt_client, None, None, 5)

        mock_mqtt_client.connect.side_effect = trigger_on_connect_fail

        with pytest.raises(TransportError, match=r"rc=5"):
            transport.connect()

    @patch("bluetti_sdk.transport.mqtt.mqtt.Client")
    def test_disconnect(self, mock_client_class, mqtt_config, mock_mqtt_client):
        """Test disconnection."""
        mock_client_class.return_value = mock_mqtt_client

        transport = MQTTTransport(mqtt_config)

        # Simulate connected state
        transport._connected = True
        transport._client = mock_mqtt_client

        transport.disconnect()

        mock_mqtt_client.unsubscribe.assert_called_once_with("PUB/TEST_DEVICE_001")
        mock_mqtt_client.disconnect.assert_called_once()
        mock_mqtt_client.loop_stop.assert_called_once()
        assert not transport.is_connected()

    @patch("bluetti_sdk.transport.mqtt.mqtt.Client")
    def test_disconnect_when_not_connected(
        self, mock_client_class, mqtt_config, mock_mqtt_client
    ):
        """Test disconnect when not connected."""
        mock_client_class.return_value = mock_mqtt_client

        transport = MQTTTransport(mqtt_config)
        transport._client = mock_mqtt_client

        # Should not raise
        transport.disconnect()

        # Should still cleanup
        mock_mqtt_client.loop_stop.assert_called_once()


class TestMQTTSendFrame:
    """Test send_frame operation."""

    @patch("bluetti_sdk.transport.mqtt.mqtt.Client")
    def test_send_frame_success(self, mock_client_class, mqtt_config, mock_mqtt_client):
        """Test successful send and receive."""
        mock_client_class.return_value = mock_mqtt_client

        transport = MQTTTransport(mqtt_config)
        transport._connected = True
        transport._client = mock_mqtt_client

        # Build valid Modbus response with correct CRC
        test_data = bytes([0x00, 0x64, 0x00, 0xC8])  # 4 bytes of data
        response_data = build_test_response(test_data)

        # Simulate response via callback
        def trigger_response(*args, **kwargs):
            # Create mock message
            mock_msg = Mock()
            mock_msg.topic = "PUB/TEST_DEVICE_001"
            mock_msg.payload = response_data

            # Trigger on_message callback
            transport._on_message(mock_mqtt_client, None, mock_msg)

            return MagicMock(wait_for_publish=MagicMock())

        mock_mqtt_client.publish.side_effect = trigger_response

        # Send frame
        request = build_modbus_request(
            device_address=1, block_address=100, register_count=2
        )
        result = transport.send_frame(request, timeout=5.0)

        assert result == response_data
        mock_mqtt_client.publish.assert_called_once()

    @patch("bluetti_sdk.transport.mqtt.mqtt.Client")
    def test_send_frame_timeout(self, mock_client_class, mqtt_config, mock_mqtt_client):
        """Test timeout when no response."""
        mock_client_class.return_value = mock_mqtt_client

        transport = MQTTTransport(mqtt_config)
        transport._connected = True
        transport._client = mock_mqtt_client

        # Don't trigger response - let it timeout
        mock_mqtt_client.publish.return_value = MagicMock(wait_for_publish=MagicMock())

        request = bytes([0x01, 0x03, 0x00, 0x64, 0x00, 0x02, 0x00, 0x00])

        with pytest.raises(TransportError, match="timeout"):
            transport.send_frame(request, timeout=0.1)

        # Verify waiting flag is cleared
        assert not transport._waiting

    @patch("bluetti_sdk.transport.mqtt.mqtt.Client")
    def test_send_frame_not_connected(
        self, mock_client_class, mqtt_config, mock_mqtt_client
    ):
        """Test sending when not connected."""
        mock_client_class.return_value = mock_mqtt_client

        transport = MQTTTransport(mqtt_config)
        # Don't set _connected

        request = bytes([0x01, 0x03, 0x00, 0x64, 0x00, 0x02, 0x00, 0x00])

        with pytest.raises(TransportError, match="Not connected"):
            transport.send_frame(request)

    @patch("bluetti_sdk.transport.mqtt.mqtt.Client")
    def test_send_frame_publish_failure(
        self, mock_client_class, mqtt_config, mock_mqtt_client
    ):
        """Test publish failure."""
        mock_client_class.return_value = mock_mqtt_client

        transport = MQTTTransport(mqtt_config)
        transport._connected = True
        transport._client = mock_mqtt_client

        mock_mqtt_client.publish.side_effect = Exception("Publish failed")

        request = bytes([0x01, 0x03, 0x00, 0x64, 0x00, 0x02, 0x00, 0x00])

        with pytest.raises(TransportError, match="Failed to publish"):
            transport.send_frame(request)

        # Verify waiting flag is cleared
        assert not transport._waiting


class TestMQTTResponseValidation:
    """Test response validation in on_message callback."""

    @patch("bluetti_sdk.transport.mqtt.mqtt.Client")
    def test_ignore_unexpected_response(
        self, mock_client_class, mqtt_config, mock_mqtt_client
    ):
        """Test ignoring response when not waiting."""
        mock_client_class.return_value = mock_mqtt_client

        transport = MQTTTransport(mqtt_config)
        transport._waiting = False

        mock_msg = Mock()
        mock_msg.payload = build_test_response(bytes([0x00, 0x64, 0x00, 0xC8]))

        # Should not raise, just ignore
        transport._on_message(mock_mqtt_client, None, mock_msg)

        # Should not store response
        assert transport._response_data is None

    @patch("bluetti_sdk.transport.mqtt.mqtt.Client")
    def test_transport_accepts_any_payload(
        self, mock_client_class, mqtt_config, mock_mqtt_client
    ):
        """Test that transport accepts any payload without validation.

        Transport layer is now protocol-agnostic and just passes bytes.
        Validation (CRC, function code, length) happens in protocol layer.
        """
        mock_client_class.return_value = mock_mqtt_client

        transport = MQTTTransport(mqtt_config)
        transport._waiting = True

        # Test 1: Too short payload - should be accepted
        mock_msg = Mock()
        mock_msg.payload = bytes([0x01, 0x03])
        transport._on_message(mock_mqtt_client, None, mock_msg)
        assert transport._response_data == bytes([0x01, 0x03])

        # Reset for next test
        transport._response_data = None
        transport._response_event.clear()

        # Test 2: Invalid function code - should be accepted
        mock_msg.payload = bytes([0x01, 0x04, 0x04, 0x00, 0x64, 0x00, 0xC8, 0x00, 0x00])
        transport._on_message(mock_mqtt_client, None, mock_msg)
        assert transport._response_data == bytes(
            [0x01, 0x04, 0x04, 0x00, 0x64, 0x00, 0xC8, 0x00, 0x00]
        )

        # Reset for next test
        transport._response_data = None
        transport._response_event.clear()

        # Test 3: Invalid CRC - should be accepted
        mock_msg.payload = bytes([0x01, 0x03, 0x04, 0x00, 0x64, 0x00, 0xC8, 0xFF, 0xFF])
        transport._on_message(mock_mqtt_client, None, mock_msg)
        assert transport._response_data == bytes(
            [0x01, 0x03, 0x04, 0x00, 0x64, 0x00, 0xC8, 0xFF, 0xFF]
        )

    @patch("bluetti_sdk.transport.mqtt.mqtt.Client")
    def test_ignore_late_response(
        self, mock_client_class, mqtt_config, mock_mqtt_client
    ):
        """Test ignoring response that arrives after timeout."""
        mock_client_class.return_value = mock_mqtt_client

        transport = MQTTTransport(mqtt_config)

        # Set waiting initially
        transport._waiting = True

        # Simulate timeout (waiting flag cleared)
        transport._waiting = False

        mock_msg = Mock()
        mock_msg.payload = build_test_response(bytes([0x00, 0x64, 0x00, 0xC8]))

        transport._on_message(mock_mqtt_client, None, mock_msg)

        # Should not store late response
        assert transport._response_data is None


class TestMQTTCallbacks:
    """Test MQTT callback handlers."""

    @patch("bluetti_sdk.transport.mqtt.mqtt.Client")
    def test_on_connect_success(self, mock_client_class, mqtt_config, mock_mqtt_client):
        """Test on_connect callback with success."""
        mock_client_class.return_value = mock_mqtt_client

        transport = MQTTTransport(mqtt_config)

        transport._on_connect(mock_mqtt_client, None, None, 0)

        assert transport._connected
        mock_mqtt_client.subscribe.assert_called_once_with("PUB/TEST_DEVICE_001", qos=1)

    @patch("bluetti_sdk.transport.mqtt.mqtt.Client")
    def test_on_connect_failure(self, mock_client_class, mqtt_config, mock_mqtt_client):
        """Test on_connect callback with failure."""
        mock_client_class.return_value = mock_mqtt_client

        transport = MQTTTransport(mqtt_config)

        transport._on_connect(mock_mqtt_client, None, None, 5)  # rc != 0

        assert not transport._connected
        mock_mqtt_client.subscribe.assert_not_called()

    @patch("bluetti_sdk.transport.mqtt.mqtt.Client")
    def test_on_disconnect(self, mock_client_class, mqtt_config, mock_mqtt_client):
        """Test on_disconnect callback."""
        mock_client_class.return_value = mock_mqtt_client

        transport = MQTTTransport(mqtt_config)
        transport._connected = True

        transport._on_disconnect(mock_mqtt_client, None, 0)

        assert not transport._connected


class TestMQTTThreadSafety:
    """Test thread-safety of MQTT transport."""

    @patch("bluetti_sdk.transport.mqtt.mqtt.Client")
    def test_request_serialization(
        self, mock_client_class, mqtt_config, mock_mqtt_client
    ):
        """Test that requests are serialized (one at a time)."""
        mock_client_class.return_value = mock_mqtt_client

        transport = MQTTTransport(mqtt_config)
        transport._connected = True
        transport._client = mock_mqtt_client

        # Verify request lock exists
        assert hasattr(transport, "_request_lock")

        # Multiple sends should be serialized via lock
        # (Can't easily test actual concurrency in unit test,
        #  but verify lock is acquired)

        # Build valid response
        test_data = bytes([0x00, 0x64, 0x00, 0xC8])
        response_data = build_test_response(test_data)

        def trigger_response(*args, **kwargs):
            mock_msg = Mock()
            mock_msg.payload = response_data
            transport._on_message(mock_mqtt_client, None, mock_msg)
            return MagicMock(wait_for_publish=MagicMock())

        mock_mqtt_client.publish.side_effect = trigger_response

        request = build_modbus_request(
            device_address=1, block_address=100, register_count=2
        )

        # First request
        result1 = transport.send_frame(request)
        assert result1 == response_data
        assert not transport._waiting  # Cleared after request

        # Second request (should work sequentially)
        result2 = transport.send_frame(request)
        assert result2 == response_data
        assert not transport._waiting

    @patch("bluetti_sdk.transport.mqtt.mqtt.Client")
    def test_waiting_flag_cleanup_on_exception(
        self, mock_client_class, mqtt_config, mock_mqtt_client
    ):
        """Test that waiting flag is cleared even on exception."""
        mock_client_class.return_value = mock_mqtt_client

        transport = MQTTTransport(mqtt_config)
        transport._connected = True
        transport._client = mock_mqtt_client

        mock_mqtt_client.publish.side_effect = Exception("Publish failed")

        request = bytes([0x01, 0x03, 0x00, 0x64, 0x00, 0x02, 0x00, 0x00])

        try:
            transport.send_frame(request)
        except TransportError:
            pass

        # Waiting flag should be cleared (via finally block)
        assert not transport._waiting
=== КОНЕЦ ФАЙЛА: tests/unit/transport/test_mqtt_mock.py ===

=== НАЧАЛО ФАЙЛА: union.py ===
-----BEGIN PRIVATE KEY-----
***MASKED***
-----END PRIVATE KEY-----
=== КОНЕЦ ФАЙЛА: union.py ===

--- END OF FILE HomeAssistant.txt ---
